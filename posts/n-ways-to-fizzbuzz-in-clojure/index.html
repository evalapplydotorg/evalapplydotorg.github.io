<!DOCTYPE html>
<html lang="en" prefix="og: https://ogp.me/ns#">
  <head>
    <!-- Some basic hygiene meta-data -->
<title>n ways to FizzBuzz in Clojure</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Aditya Athalye">
<meta name="description"
      content="FizzBuzz is everywhere. Every programmer passes through its rite of passage, or at least bears witness to another. Over the years, many gentlenerds have taken it upon themselves to discover ever new ways to incant those hoary symbols. I hereby enjoin these few drops of Clojure to that roiling ocean of FizzBuzzery.">
<meta name="keywords" content="systems thinking,functional programming,architecture,software design,technology leadership,devops,clojure">
<meta property="og:title" content="n ways to FizzBuzz in Clojure">
<meta property="og:description" content="FizzBuzz is everywhere. Every programmer passes through its rite of passage, or at least bears witness to another. Over the years, many gentlenerds have taken it upon themselves to discover ever new ways to incant those hoary symbols. I hereby enjoin these few drops of Clojure to that roiling ocean of FizzBuzzery.">
<meta property="og:locale" content="en_GB">
<meta property="og:type" content="website">
<meta property="og:url" content="https://evalapply.org/posts/n-ways-to-fizzbuzz-in-clojure/index.html">
    <link rel="stylesheet preload" type="text/css" as="style" href="https://evalapply.org/static/css/style.css">
<link href="https://evalapply.org/index.xml"
      rel="alternate" type="application/rss+xml"
      title="Eval / Apply is pure magic">
<link rel="canonical" href="https://evalapply.org/posts/n-ways-to-fizzbuzz-in-clojure/index.html">
</head>
  <body>
    <div id="the-very-top" class="stack center box">
        <header id="site-header">
  <div class="box invert stack">
    <div class="with-sidebar site-header">
      <a class="box icon" href="https://evalapply.org/index.html#main">
        <img src="https://evalapply.org/static/img/Lisp_logo.svg" alt="Eval / Apply is pure magic">
      </a>
      <div class="stack">
        <div class="site-header site-header:title">Eval / Apply is pure magic</div>
        <nav class="cluster site-header site-header:nav-items">
          <a href="https://evalapply.org/index.html#the-very-top">
   &lambda; about
</a>
<a href="https://evalapply.org/posts/index.html">
   &#9753; blog
</a>
<a href="mailto:hello@evalapply.org">
   email
</a>
<a href="#site-footer">
   &rlhar; subscribe
</a>
        </nav>
      </div>
    </div>
  </div>
</header>
        <main id="main">
          <article id="blog-post" class="stack">
  <header>
    <div class="stack">
      <div class="title">n ways to FizzBuzz in Clojure</div>
      <div class="cluster post-meta"><span>&uarr; <a href="#site-header" rel="bookmark">menu</a></span>
        <span>&darr; <a href="#blog-post-toc" rel="bookmark">toc</a></span></div>
      <div class="summary">FizzBuzz is everywhere. Every programmer passes through its rite of passage, or at least bears witness to another. Over the years, many gentlenerds have taken it upon themselves to discover ever new ways to incant those hoary symbols. I hereby enjoin these few drops of Clojure to that roiling ocean of FizzBuzzery.</div>
      <div class="cluster post-meta">
        <span class="author">By: Adi</span>
        <span class="date">Published: 2022-03-25</span>
        <span class="date">Updated: 2022-11-08</span>
        <span class="tags">Tags:  / <a href="https://evalapply.org/tags/clojure/index.html#main">#clojure</a> / <a href="https://evalapply.org/tags/functional_programming/index.html#main">#functional_programming</a> / <a href="https://evalapply.org/tags/howto/index.html#main">#howto</a>
        </span>
      </div>
      <hr>
    </div>
  </header>
  <section class="stack">
      <div id="blog-post-toc" class="stack table-of-contents">
  <details class="box invert stack" open>
    <summary>
      <strong>Contents</strong>
    </summary>
    <nav class="stack">
      <a href="#usage-guide" class="toc-heading:h1">Usage guide</a>
<a href="#reading-the-code" class="toc-heading:h2">Reading the code</a>
<a href="#running-the-code" class="toc-heading:h2">Running the code</a>
<a href="#complaining-about-the-code" class="toc-heading:h2">Complaining about the code</a>
<a href="#le-fizzbuzz-classique" class="toc-heading:h1">Le FizzBuzz Classique</a>
<a href="#le-fizzbuzz-classique-est-mort-à-clojure.-désolé" class="toc-heading:h2">Le FizzBuzz Classique est mort à Clojure. Désolé :(</a>
<a href="#le-fizzbuzz-classique-remedied" class="toc-heading:h2">Le FizzBuzz Classique, remedied</a>
<a href="#le-fizzbuzz-classique-dissected" class="toc-heading:h2">Le FizzBuzz Classique, dissected</a>
<a href="#le-fizzbuzz-classique-doseqd" class="toc-heading:h2">Le FizzBuzz Classique, doseq'd</a>
<a href="#le-fizzbuzz-classique-doalld" class="toc-heading:h2">Le FizzBuzz Classique, doall'd</a>
<a href="#little-functions-are-good" class="toc-heading:h1">Little functions are good!</a>
<a href="#map-reduce-for-fizzbuzz" class="toc-heading:h1">map reduce for FizzBuzz</a>
<a href="#domain-driven-design-fizzbuzz" class="toc-heading:h1">Domain Driven Design FizzBuzz</a>
<a href="#actually-domain-driven-fizzbuzz" class="toc-heading:h1">Actually Domain Driven FizzBuzz</a>
<a href="#fizzbuzz-by-construction" class="toc-heading:h1">FizzBuzz by construction</a>
<a href="#interlude-all-the-fizz-buzzes-so-far" class="toc-heading:h1">Interlude: all the fizz-buzzes so far</a>
<a href="#peano-fizzbuzz" class="toc-heading:h1">Peano FizzBuzz</a>
<a href="#dispatch-buzz" class="toc-heading:h1">Dispatch Buzz</a>
<a href="#embarrassingly-parallel-fizzbuzz" class="toc-heading:h1">Embarrassingly Parallel FizzBuzz</a>
<a href="#oop-buzz" class="toc-heading:h1">OOP Buzz</a>
<a href="#non-destructive-fizzbuzz" class="toc-heading:h1">Non-Destructive FizzBuzz</a>
<a href="#composite-data-buzz" class="toc-heading:h2">Composite Data Buzz</a>
<a href="#clojure-specd-buzz" class="toc-heading:h2">Clojure Spec'd Buzz</a>
<a href="#wicked-pprint-buzz" class="toc-heading:h2">Wicked pprint Buzz</a>
<a href="#tagged-literal-buzz" class="toc-heading:h2">Tagged Literal Buzz</a>
<a href="#interlude-what-more-could-we-possibly-decomplect" class="toc-heading:h1">Interlude: What more could we possibly decomplect?</a>
<a href="#transducery-buzz" class="toc-heading:h1">Transducery Buzz</a>
<a href="#what-are-we-decomplecting" class="toc-heading:h2">What are we decomplecting?</a>
<a href="#demo-one-computation-and-output-format-pulled-apart" class="toc-heading:h2">Demo One: Computation and <em>Output</em> format pulled apart</a>
<a href="#demo-two-computation-and-input-format-pulled-apart." class="toc-heading:h2">Demo Two: Computation and <em>Input</em> format pulled apart.</a>
<a href="#demo-three-use-only-the-xform-as-a-calculator" class="toc-heading:h2">Demo Three: Use <em>only</em> the xform as a calculator</a>
<a href="#further-reading" class="toc-heading:h2">Further reading</a>
<a href="#buzz" class="toc-heading:h1"><span class="todo TODO">TODO</span> Buzz</a>
<a href="#acknowledgments" class="toc-heading:h1">Acknowledgments</a>
    </nav>
  </details>
</div>
<hr>
  <p>The brainwave here is to (mis)use the feature set of Clojure and its standard library to cook up as many ways to encode FizzBuzz as one can muster (or steal). If all goes well, this post will receive many updates. If it goes <em>really</em> well, all sorts of bad ideas and clever foot-guns will be discovered and used.</p>
<p>The creative constraint is this: any FizzBuzz, however terrible or hilarious, <em>must also be useful</em>. It should have reason to exist and should reveal some real-world Clojure thinking.</p>
<p>That means no <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">FizzBuzzEnterpriseEdition</a> but also no Dylan Beattie's brilliant <a href="https://www.youtube.com/watch?v=6avJHaC3C2U&amp;t=3350s">FizzBuzz in RockStar</a>. So sorry!</p>
<p>Not to be indelicate, but I will state the problem before proceeding.</p>
<blockquote>
<p>Fizz buzz is a group word game for children to teach them about division. Players take turns to count incrementally, replacing any number divisible by three with the word "fizz", and any number divisible by five with the word "buzz".</p>
<p>— <a href="https://en.wikipedia.org/wiki/Fizz_buzz">https://en.wikipedia.org/wiki/Fizz_buzz</a></p>
</blockquote>
<p>Needless to say, they mean natural numbers starting at 1 when they say "numbers".</p>
<p>Phew that was rough on the ego. Let us compose ourselves for a minute.</p>
<p>…</p>
<p>OK, onward.</p>
<h1 id="usage-guide">Usage guide</h1>
<h2 id="reading-the-code">Reading the code</h2>
<ul>
<li><p>Find the <code>check-all-fizz-buzzers</code> function below, for usage examples.</p></li>
<li><p>We use functions only from Clojure's standard library (clojure.core).</p></li>
<li><p>Lookup unfamiliar functions at <a href="https://clojuredocs.org/quickref">https://clojuredocs.org/quickref</a>, helpfully illustrated with community-contributed examples.</p></li>
</ul>
<h2 id="running-the-code">Running the code</h2>
<ul>
<li><p>If you don't already have <a href="https://clojure.org/guides/getting_started">Clojure installed</a>, you can run the code online at <a href="https://tryclojure.org/">https://tryclojure.org/</a> (fully client-side, but minimalist), or at <a href="https://repl.it/languages/clojure">https://repl.it/languages/clojure</a> (feature-rich web-based IDE, but requires signup).</p></li>
<li><p>Preferably, copy over code as you go along. Try it out bit by bit.</p></li>
<li><p>If you are in a hurry, find the "Interlude" section and copy over all the code from there.</p></li>
<li><p>Finally, run <code>(check-all-fizz-buzzers)</code> to see if it all works as expected.</p></li>
</ul>
<h2 id="complaining-about-the-code">Complaining about the code</h2>
<ul>
<li>If I've made bugs in the Code or the English (possible) or made egregious remarks (very possible), please write to <em>weblog</em> at this website. I'll fix the bugs.</li>
</ul>
<p>Right, then. Shall we begin?</p>
<h1 id="le-fizzbuzz-classique">Le FizzBuzz Classique</h1>
<p>In the beginning, one might trawl the Clojure standard library for familiar, safe-looking words and accidentally discover <code>for</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Python or Javascript gentlenerds may say <em>"Ooh, List Comprehension. Nice!"</em>, and bang out <em>Le FizzBuzz Classique</em>. Java or C# gentlenerds may struggle a lot more, because Clojure has no <code>Class</code>. We are sorry for this disappointment. Please follow the Python for now.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> fizz-buzz-classic</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  [num-xs]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  (<span class="kw">for</span> [n num-xs]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">15</span>)) (<span class="kw">println</span> <span class="st">&quot;FizzBuzz&quot;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">3</span>)) (<span class="kw">println</span> <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">5</span>)) (<span class="kw">println</span> <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>      <span class="at">:else</span> (<span class="kw">println</span> n))))</span></code></pre></div>
<p>Then you will evaluate it <em>in</em> the "REPL", et voilà! Something très familiar!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>user=&gt; (fizz-buzz-classic (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">16</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>Fizz</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>Buzz</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>FizzBuzz</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="dv">16</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>(<span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span>)</span></code></pre></div>
<p>(Except for that pesky last line full of nils. But like, whatever. It worked.).</p>
<h2 id="le-fizzbuzz-classique-est-mort-à-clojure.-désolé">Le FizzBuzz Classique est mort à Clojure. Désolé :(</h2>
<p>Sadly, the spurious nils are the least of your woes. You just fell prey to something called "Laziness", and the code is dead on arrival, but you don't know it yet because evaluating <em>in</em> the "REPL" obscures this fact.</p>
<p>Welcome to Functional Programming (FP) with lazy sequences, which is <em>awesome</em>, but which is also one of the double edges of Clojure that will cut you if you come here with set ideas about How Things Ought To Work.</p>
<p>Saying it in French (however broken) felt gentler, somehow.</p>
<p>At this point, you might accuse me of setting you up with this strawman <code>for</code>. In response, I might simply wait for your production to blow up. Unknowing mixing of laziness and side effects reliably trips up all programmers new to Clojure <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Luckily we can avoid going down that rabbit hole <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> entirely, because there is a more pressing problem that makes <em>Le FizzBuzz Classique</em> look severely defective to this Clojurist's FP-addled brain. Fixing that makes the point of lazy sequences moot, as a nice bonus.</p>
<h2 id="le-fizzbuzz-classique-remedied">Le FizzBuzz Classique, remedied</h2>
<p>Behold this cleaned up version.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> lazybuzz</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  [num-xs]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  (<span class="kw">for</span> [n num-xs]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">15</span>)) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">3</span>)) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">5</span>)) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>      <span class="at">:else</span> n)))</span></code></pre></div>
<p>Yes, <code>println</code> is no more, and…</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>user=&gt; (lazybuzz (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">16</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>(<span class="dv">1</span> <span class="st">&quot;Fizz&quot;</span> <span class="st">&quot;Buzz&quot;</span> <span class="st">&quot;FizzBuzz&quot;</span> <span class="dv">16</span>)</span></code></pre></div>
<p>Compare the shape of the collection of nils seen classically, with what we see now. They are both sequences with the same number of items, <em>but</em> the new one contains useful values (insert :trollface: :).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>user=&gt; (fizz-buzz-classic (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">19</span>))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>Fizz</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>Buzz</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>FizzBuzz</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="dv">19</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>(<span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span>) <span class="co">; 5 prints, 5 nils</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>user=&gt; (lazybuzz (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">19</span>))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>(<span class="dv">1</span> <span class="st">&quot;Fizz&quot;</span> <span class="st">&quot;Buzz&quot;</span> <span class="st">&quot;FizzBuzz&quot;</span> <span class="dv">19</span>) <span class="co">; no prints, 1 value containing 5 values</span></span></code></pre></div>
<p>Well, that's because all expressions in Clojure return a value. <code>println</code> creates a side effect of printing and has a return value of <code>nil</code>. Thus for each item in the input range, the "impure" classic version prints to the REPL, collects the return value of each println (nil), and returns that collection.</p>
<p>The "purified" fizz-buzz simply calculates a result for each branch and the <code>for</code> returns the accumulated result. And now the results are printed inside parentheses, which is, like, sure whatever. At least it <em>looks</em> like it's doing the right calculations <em>and</em> the pesky nils are gone, so we can move on?</p>
<p>Not so fast.</p>
<h2 id="le-fizzbuzz-classique-dissected">Le FizzBuzz Classique, dissected</h2>
<p>To FizzBuzz creatively in Clojure, we must examine <em>and avoid</em> the defects of the classic version, which are as follows.</p>
<ol>
<li><strong>Broken behaviour</strong>: <code>println</code> alters the state of the world and thus injects non-determinism into an otherwise purely functional calculation. This is anathema <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> to Clojurists (and FP practitioners at large).</li>
<li><strong>Broken API contract</strong>: We get back a useless collection nils, instead of the result of a calculation that we can use further. We prefer to always write functions that return useful values.</li>
<li><strong>Broken time model</strong>: Effects want to happen "now" (here, printing to some output device), while lazy computations want to happen "maybe never" (here, a definition that maps the domain of a collection of countless numbers to the domain of FizzBuzz). Effects and laziness can be made to pair well, <em>but only when</em> we define them separately from the get go, and have some third way of joining them together safely when needed. For now, you could do worse than lasering this into your brain: "Never mix (side) effects and laziness.".</li>
<li><strong>Broken aesthetic</strong>: We like our functions to do one job, and do it well. Printing things is a <em>second</em> job, and as Messers Hal and Gerry like to say in SICP <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, "That's George's problem.".</li>
</ol>
<p>Henceforth, all functions shall be pure calculations, and we will rely on our metaphorical George "the REPL" Ableman to handle all our print jobs.</p>
<p>As an added benefit, writing pure functions makes laziness such a good friend, that we don't even need to acknowledge its presence.</p>
<p>Yet another benefit is that we won't have to burn hundreds of words to apologise for broken code <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>See? Such passion. I wasn't joking when I said "looks severely defective to me" <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<h2 id="le-fizzbuzz-classique-doseqd">Le FizzBuzz Classique, doseq'd</h2>
<p>Maybe you still aren't convinced. <code>println</code> is such a global standard. <em>Easy</em> <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. So you might dig into the standard library more and come up with <code>doseq</code> to eliminate laziness…</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> doseq-fizz-buzz</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  [num-xs]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  (<span class="kw">doseq</span> [n num-xs]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">15</span>)) (<span class="kw">println</span> <span class="st">&quot;FizzBuzz&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">3</span>)) (<span class="kw">println</span> <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>      (<span class="kw">zero?</span> (<span class="kw">rem</span> n <span class="dv">5</span>)) (<span class="kw">println</span> <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>      <span class="at">:else</span> (<span class="kw">println</span> n))))</span></code></pre></div>
<p>And declare victory…</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>user=&gt; (doseq-fizz-buzz (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">19</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>Fizz</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>Buzz</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>FizzBuzz</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="dv">19</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="va">nil</span> <span class="co">; maybe we can live with just one nil?</span></span></code></pre></div>
<p>But the code is still fatally broken for the other reasons, and now <em>it is also worse</em>, because this implementation cannot say "here are <em>all</em> the fizzbuzzes". Only a lazy definition can say this <em>and</em> allow you to carry on computing. Besides, <code>doseq</code> is meant for cases when we <em>want to cause</em> side effects. And the functional Clojurist almost never <em>wants</em> to.</p>
<p>Remember the children's game definition of FizzBuzz? It is beautiful because it <em>does not</em> say "FizzBuzz only for the first K numbers". Now if you go DuckDuck search the standard coding interview version of the question, what do you find? "Write a program that prints the numbers from 1 to 100 such that…".</p>
<p>Boo.</p>
<h2 id="le-fizzbuzz-classique-doalld">Le FizzBuzz Classique, doall'd</h2>
<p>As a famous TV detective would say; "Oh, just one other thing.". Here are ways to break your programs. And if you are feeling suitably adventurous, to also test the stability of your employment.</p>
<p>The following invocation of <code>lazybuzz</code> in your <code>-main</code> would not be fine, assuming you wanted to do something useful with it. But would also not precipitate anything terrible.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> -main</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="st">&quot;The entry point to your microservice.&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  [&amp; args]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="co">;; Do things ...</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m about to do...&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  <span class="co">;; No block, no foul.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  (lazybuzz (<span class="kw">range</span>))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  <span class="co">;; Sure, why not ...</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m done!&quot;</span>))</span></code></pre></div>
<p>Here is a good way to break your software <span class="underline">and</span> print FizzBuzzes to the console indefinitely (or at least as long as your computer can make new numbers).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> -main</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="st">&quot;The entry point to your microservice.&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  [&amp; args]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="co">;; Do things ...</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m about to do...&quot;</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  <span class="co">;; Spin wheels until the numbers run out.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  (doseq-fizz-buzz (<span class="kw">range</span>))</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  <span class="co">;; Maybe never ...</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m done!&quot;</span>))</span></code></pre></div>
<p>As a funner party trick, if you make a computer (VM) with a bad output device (or redirect program output to /dev/full), then you can crash or hang your program. If you discover it crashes, feel free to daemonise it and make an infinitely restarting JVM process that does nothing but burn CPU cycles. Take that, cryptominers!</p>
<p>To be fair, you can also break programs with lazy evaluation, with the added benefit of doing it silently. But at least you are forced to say <code>doall</code>, which might make you feel at least a tiny bit guilty.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> -main</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="st">&quot;The entry point to your microservice.&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  [&amp; args]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  <span class="co">;; Do things...</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m about to do...&quot;</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="co">;; Spin wheels silently, until OOM or no more numbers,</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="co">;; whichever happens first.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>  (<span class="kw">doall</span> (lazybuzz (<span class="kw">range</span>)))</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  <span class="co">;; Maybe not ...</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m done!&quot;</span>))</span></code></pre></div>
<p>To see if you can get <em>fired</em> by solving fizzbuzz (now that's a concept, innit?), you can ship to production <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> the…</p>
<ul>
<li>doseq version, to fill up your log files with fizzbuzz. They will fill up really fast. Faster than logrotate.</li>
<li>doall lazybuzz version, to confuse the daylights out of everyone, at least until your process dies with OOM.</li>
<li>badly daemonised verison, to enjoy repeated restart cycles through crashes from number overflows and/or OOMs.</li>
<li>Or something actually dangerous…</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> -main</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="st">&quot;The entry point to your microservice.&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  [&amp; args]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="co">;; Do things...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m about to do...&quot;</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  <span class="co">;; Your /thought/ you were going to /do/ something useful here.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  (fizz-buzz-classic (<span class="kw">range</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>  <span class="co">;; You now falsely believe you did something useful ...</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  (<span class="kw">println</span> <span class="st">&quot;I&#39;m done!&quot;</span>))</span></code></pre></div>
<p>I assure you, experienced Clojurists are no longer grinning at the tomfoolery. Many of us have shipped <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> (or <em>almost</em> shipped) this category of bugs to prod. Not fun.</p>
<p>OK, now I consider <em>Le Cheval Classique</em> suitably flogged postmortem, and yourself suitably <em>Caveat Emptor</em>-ed.</p>
<p>Now we will FizzBuzz joyously.</p>
<h1 id="little-functions-are-good">Little functions are good!</h1>
<p>Once we remove the <em>ick</em> of <code>println</code> from our code, we can see further room for improvement. <code>(zero? (rem n divisor))</code> is not only a common pattern, it is actually a distinct <em>idea</em>, viz. "Is <code>n</code> <em>divisible</em> by <code>divisor</code>?".</p>
<p>We can name it locally, with <code>let</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> letbuzz</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  [num-xs]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  (<span class="kw">for</span> [n num-xs]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    (<span class="kw">let</span> [divisible? (<span class="kw">fn</span> [n1 n2] (<span class="kw">zero?</span> (<span class="kw">rem</span> n1 n2)))] <span class="co">; locally-bound lambda</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>      (<span class="kw">cond</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>        (divisible? n <span class="dv">15</span>) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>        (divisible? n <span class="dv">3</span>) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>        (divisible? n <span class="dv">5</span>) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>        <span class="at">:else</span> n))))</span></code></pre></div>
<p><em>However</em>, this definition of divisibility is generally applicable to numbers, so it makes sense to define a top-level global concept.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> divisible?</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="st">&quot;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  (<span class="kw">fn</span> [n1 n2] (<span class="kw">zero?</span> (<span class="kw">rem</span> n1 n2))))</span></code></pre></div>
<p>Yep, <code>defn</code> is just <code>def</code> + <code>fn</code> under the hood, and we can conveniently write the same thing as follows.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> divisible?</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="st">&quot;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  [n1 n2]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  (<span class="kw">zero?</span> (<span class="kw">rem</span> n1 n2)))</span></code></pre></div>
<p>We can also use <code>comp</code> to define divisibility more succinctly.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> divisible?</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  <span class="st">&quot;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  (<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>))</span></code></pre></div>
<p>Since the various implementations of <code>divisible?</code> are all pure functions, they are drop-in replacements for each other ("referentially transparent"). Use whichever version you like best.</p>
<p>It may seem silly to write such tiny functions, but we earn a lot of firepower by lifting out named domain concepts, <em>especially</em> the simple ones, because we can <em>compose</em> them flexibly to express other domain concepts as needed.</p>
<h1 id="map-reduce-for-fizzbuzz">map reduce for FizzBuzz</h1>
<p>Here's a doozy. By putting FizzBuzz <em>logic</em> inside <code>for</code>, we have in fact deeply intertwined <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> two very distinct computations; viz. sequence generation, and choice-making.</p>
<p>Suppose we lifted out the decision logic into its own function?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> basic-buzz</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  <span class="st">&quot;We can also trivially rewrite this with &#39;condp&#39;.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="st">  ref: https://clojuredocs.org/clojure.core/condp&quot;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  [n]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  (<span class="kw">cond</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    (divisible? n <span class="dv">15</span>) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    (divisible? n <span class="dv">3</span>) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    (divisible? n <span class="dv">5</span>) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    <span class="at">:else</span> n))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>  <span class="co">;; Unsurprisingly...</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>  (basic-buzz <span class="dv">1</span>) =&gt; <span class="dv">1</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>  (basic-buzz <span class="dv">3</span>) =&gt; <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>  (basic-buzz <span class="dv">5</span>) =&gt; <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>  (basic-buzz <span class="dv">15</span>) =&gt; <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Now we can bring back <code>for</code> this way…</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-fizz-buzzes</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  (<span class="kw">for</span> [n (<span class="kw">rest</span> (<span class="kw">range</span>))]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    (basic-buzz n)))</span></code></pre></div>
<p>But our new choice opens up the design space, because we can directly say "this is just a mapping of the domain of numbers to the domain of FizzBuzz".</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-fizz-buzzes</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  (<span class="kw">map</span> basic-buzz (<span class="kw">rest</span> (<span class="kw">range</span>))))</span></code></pre></div>
<p>Now since <code>map</code> is conceptually just a special case of <code>reduce</code>, we could write the following. <em>However</em> in Clojure, <code>map</code> is lazy but <code>reduce</code> is eager, and we only use <em>reduce</em> when we want to force a final calculation.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> just-some-fizz-buzzes</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  (<span class="kw">reduce</span> (<span class="kw">fn</span> [result n]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>            (<span class="kw">conj</span> result</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>                  (basic-buzz n)))</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>          []</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>          <span class="co">;; the classic programmer&#39;s problem statement</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>          (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">101</span>)))</span></code></pre></div>
<p>Once again, we earned more compositional power by lifting out another small concept. Let's do some more of that.</p>
<h1 id="domain-driven-design-fizzbuzz">Domain Driven Design FizzBuzz</h1>
<p>We can further define concepts specific to the business domain of FizzBuzz. This opens up our design space even more.</p>
<p>Before that I'll make one small tweak to help us express ourselves better. I'll rearrange the argument list of <code>divisible?</code> so that the "more constant" argument is placed first, and successively more variable argument(s) are placed successively. Also rely on "truthiness" in Clojure to imply yes/no.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> divisible?</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  <span class="st">&quot;Given a number &#39;n&#39;, return the given word (truthy) when it is divisible</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="st">   by the divisor, or nil otherwise (falsey).&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  [divisor the-word n]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  (<span class="kw">when</span> (<span class="kw">zero?</span> (<span class="kw">rem</span> n divisor))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    the-word))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzes?</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>  <span class="st">&quot;Is a given number divisible by 3?&quot;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  (<span class="kw">partial</span> divisible? <span class="dv">3</span> <span class="st">&quot;Fizz&quot;</span>))</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> buzzes?</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>  <span class="st">&quot;Is a given number divisible by 5?&quot;</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>  (<span class="kw">partial</span> divisible? <span class="dv">5</span> <span class="st">&quot;Buzz&quot;</span>))</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzbuzzes?</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>  <span class="st">&quot;Is a given number divisible by 3 and 5?&quot;</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>  (<span class="kw">partial</span> divisible? <span class="dv">15</span> <span class="st">&quot;FizzBuzz&quot;</span>))</span></code></pre></div>
<p>Now we can rewrite <code>basic-buzz</code> using <code>or</code>, which short-circuits, and returns the first <em>truthy</em> value it encounters. You will see this construct in real-world Clojure code.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> or-buzz</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  <span class="st">&quot;Just like conditional matching, but exploit short-circuit behaviour of &#39;or&#39;.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="st">   Sadly, order of conditionals still matters.&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  [n]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  (<span class="kw">or</span> (fizzbuzzes? n)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>      (buzzes? n)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>      (fizzes? n)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>      n))</span></code></pre></div>
<p>We argued that we are essentially expressing a choice, and that we can even do it with <code>juxt</code>, because once we grok <code>juxt</code>, we want to use it <em>everywhere</em>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> juxt-buzz</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  <span class="st">&quot;juxt for fun:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="st">       e.g. ((juxt f g h) 42) -&gt; [(f 42) (g 42) (h 42)]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="st">       cf. https://clojuredocs.org/clojure.core/juxt</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="st">   Sadly, order of conditional checks still matters, which combined with</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="st">   the nil-punning that&#39;s going on here is too subtle for production use.&quot;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  [n]</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>  (<span class="kw">some</span> <span class="kw">identity</span> ((<span class="kw">juxt</span> fizzbuzzes? buzzes? fizzes? <span class="kw">identity</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>                  n)))</span></code></pre></div>
<p>Yeah, that's a head-scratcher. Best leave it back at home.</p>
<h1 id="actually-domain-driven-fizzbuzz">Actually Domain Driven FizzBuzz</h1>
<p>You might protest that well actually the clever little functions, in fact, express the domain of the <em>solution</em> (the business of calculating FizzBuzz), not the domain of the <em>problem</em> (arithmetic representation of FizzBuzz).</p>
<p>And even though I flunked maths a lot, I would concur. So here goes nothing…</p>
<p>15 is the least common multiple of the prime factors. Suppose we cook up an encoding scheme based on remainders of 15, and write it down as a lookup table? We can then find <code>(rem n 15)</code>, and look up the answer to FizzBuzz in the table.</p>
<p>Why do a lookup table? Well, what is the simplest possible function? A literal hard-coded lookup table!</p>
<p>In Clojure, we can use hash-maps to write down look-up tables.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">;; A table of remainders of 15, in a hash-map.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>{<span class="dv">0</span>  <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a> <span class="dv">3</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a> <span class="dv">6</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a> <span class="dv">9</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a> <span class="dv">12</span> <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a> <span class="dv">5</span>  <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a> <span class="dv">10</span> <span class="st">&quot;Buzz&quot;</span>}</span></code></pre></div>
<p>And here is a very fun and useful fact. Clojure hash-maps are not just inert data. They also behave as functions of their keys. We can literally call <code>({:a 42} :a)</code> and get back 42. Noice!</p>
<p>So suppose we define a global lookup table?</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> rem15-&gt;fizz-buzz</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  {<span class="dv">0</span>  <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>   <span class="dv">3</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>   <span class="dv">6</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>   <span class="dv">9</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>   <span class="dv">12</span> <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>   <span class="dv">5</span>  <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>   <span class="dv">10</span> <span class="st">&quot;Buzz&quot;</span>})</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>  (rem15-&gt;fizz-buzz (<span class="kw">rem</span> <span class="dv">3</span> <span class="dv">15</span>)) =&gt; <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>  (rem15-&gt;fizz-buzz (<span class="kw">rem</span> <span class="dv">5</span> <span class="dv">15</span>)) =&gt; <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a>  (rem15-&gt;fizz-buzz (<span class="kw">rem</span> <span class="dv">15</span> <span class="dv">15</span>)) =&gt; <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  (rem15-&gt;fizz-buzz (<span class="kw">rem</span> <span class="dv">1</span> <span class="dv">15</span>)) =&gt; <span class="va">nil</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>  )</span></code></pre></div>
<p>See the <code>nil</code> returned for "no result found"? If you were paying attention to the nil punning <a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>, and the short-circuiting <code>or</code>, you might get the following idea. And you would not be wrong.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> or-rem15-buzz</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  [n]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  (<span class="kw">or</span> (rem15-&gt;fizz-buzz (<span class="kw">rem</span> n <span class="dv">15</span>))</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>      n))</span></code></pre></div>
<p>But we can be more right by using the <code>get</code> function, which is designed for use with hash-maps, and which allows us to conveniently specify a fallback value for the "not found" case.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> get-rem15-buzz</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>  [n]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  (<span class="kw">get</span> rem15-&gt;fizz-buzz</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>       (<span class="kw">rem</span> n <span class="dv">15</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>       n))</span></code></pre></div>
<p>Not to press the point, but they are referentially transparent.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>(<span class="kw">=</span> (<span class="kw">map</span> or-rem15-buzz (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">16</span>))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>   (<span class="kw">map</span> get-rem15-buzz (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">16</span>)))</span></code></pre></div>
<p>You may have also astutely noted that, in both the implementations above, the order of calculation ceases to matter. Now we are doing maths.</p>
<h1 id="fizzbuzz-by-construction">FizzBuzz by construction</h1>
<p>Closely related to remainder lookup tables, we can make the observation that FizzBuzz is cyclical in modulo 3, 5, and 15. So we can directly define the <em>idea</em> of FizzBuzz in those terms.</p>
<p>This FizzBuzz is correctly ordered <em>by definition</em>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> mod-cycle-buzz</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  <span class="st">&quot;We can declare a lazy sequence of FizzBuzz as modulo 3, 5, 15.</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a><span class="st">  The sequence is ordered by definition.&quot;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  (<span class="kw">let</span> [n  <span class="kw">identity</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>        f  (<span class="kw">constantly</span> <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>        b  (<span class="kw">constantly</span> <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>        fb (<span class="kw">constantly</span> <span class="st">&quot;FizzBuzz&quot;</span>)]</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>    (<span class="kw">cycle</span> [n n f</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>            n b f</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>            n n f</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a>            b n f</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>            n n fb])))</span></code></pre></div>
<p>Now, Clojure's <code>map</code> is not only lazy, it can also apply a function of <code>n</code> arguments over <code>n</code> collections until any one of the collections is exhausted. So we can…</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-fizz-buzzes</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  (<span class="kw">map</span> (<span class="kw">fn</span> [f n] (f n))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>       mod-cycle-buzz <span class="co">; countless modulo pattern</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>       (<span class="kw">rest</span> (<span class="kw">range</span>)))) <span class="co">; countless sequence of numbers</span></span></code></pre></div>
<p>If we think in terms of the prime factors 3 and 5, along with modulo cycles, it may inspire a generalised version of fizzbuzz, like so.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> any-mod-cycle-buzz</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>  <span class="st">&quot;Given a number and a sequence of words mapping to prime factors,</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="st">   either return the corresponding word-version for the number position,</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span class="st">   or the number itself, if no prime factor exists.</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a><span class="st">   Basically, the set of words should map to set of prime factors.</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a><span class="st">   We also don&#39;t make any assumptions about order of words here. It is up</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a><span class="st">   to the caller to choose whatever sequence they please.&quot;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>  [<span class="kw">num</span> &amp; words]</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>  (<span class="kw">or</span> (<span class="kw">not-empty</span> (<span class="kw">reduce</span> <span class="kw">str</span> words))</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>      <span class="kw">num</span>))</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>(<span class="kw">map</span> any-mod-cycle-buzz</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>     (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">16</span>)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a>     (<span class="kw">cycle</span> [<span class="va">nil</span> <span class="va">nil</span> <span class="st">&quot;Fizz&quot;</span>])</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>     (<span class="kw">cycle</span> [<span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="st">&quot;Buzz&quot;</span>]))</span></code></pre></div>
<p>And last but not least, this interpretation allows us to express the arithmetic <em>identity</em> of the whole category of FizzBuzzes, which is, just the number sequence itself. (As in, the identity of + is 0 and that of * is 1).</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>(<span class="kw">map</span> any-mod-cycle-buzz</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>     (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">16</span>))</span></code></pre></div>
<p>But then again, I've flunked maths too often to be confident about any of this. Please complain to me if I'm wrong.</p>
<h1 id="interlude-all-the-fizz-buzzes-so-far">Interlude: all the fizz-buzzes so far</h1>
<p>I'll drop this mini <em>pièce de résistance</em> (for now), and pause for a breather. I've copied down all the fizz-buzz variants (minus doc strings for brevity).</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>(<span class="kw">ns</span> all.them.fizz.buzzers)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz </span><span class="kw">map</span>) <span class="co">; now, what `map` can do fizz-buzz can too</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a><span class="co">;; Le FizzBuzz Classique Functional</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> basic-buzz</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>  [n]</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>  (<span class="kw">let</span> [divisible? (<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>)]</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>      (divisible? n <span class="dv">15</span>) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>      (divisible? n <span class="dv">5</span>) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a>      (divisible? n <span class="dv">3</span>) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a>      <span class="at">:else</span> n)))</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true"></a><span class="co">;; Branching logic FizzBuzzes</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> divisible?</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true"></a>  [divisor the-word n]</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true"></a>  (<span class="kw">when</span> (<span class="kw">zero?</span> (<span class="kw">rem</span> n divisor))</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true"></a>    the-word))</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">3</span> <span class="st">&quot;Fizz&quot;</span>))</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> buzzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">5</span> <span class="st">&quot;Buzz&quot;</span>))</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzbuzzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">15</span> <span class="st">&quot;FizzBuzz&quot;</span>))</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true"></a></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> or-buzz</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true"></a>  [n]</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true"></a>  (<span class="kw">or</span> (fizzbuzzes? n)</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true"></a>      (buzzes? n)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true"></a>      (fizzes? n)</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true"></a>      n))</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true"></a></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> juxt-buzz</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true"></a>  [n]</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true"></a>  (<span class="kw">some</span> <span class="kw">identity</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true"></a>        ((<span class="kw">juxt</span> fizzbuzzes? buzzes? fizzes? <span class="kw">identity</span>)</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true"></a>         n)))</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true"></a></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true"></a></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true"></a><span class="co">;; More mathematical FizzBuzzes</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> rem15-&gt;fizz-buzz</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true"></a>  {<span class="dv">0</span>  <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true"></a>   <span class="dv">3</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true"></a>   <span class="dv">6</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true"></a>   <span class="dv">9</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true"></a>   <span class="dv">12</span> <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true"></a>   <span class="dv">5</span>  <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true"></a>   <span class="dv">10</span> <span class="st">&quot;Buzz&quot;</span>})</span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true"></a></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> or-rem15-buzz</span></span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true"></a>  [n]</span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true"></a>  (<span class="kw">or</span> (rem15-&gt;fizz-buzz (<span class="kw">rem</span> n <span class="dv">15</span>))</span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true"></a>      n))</span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true"></a></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> get-rem15-buzz</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true"></a>  [n]</span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true"></a>  (<span class="kw">get</span> rem15-&gt;fizz-buzz</span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true"></a>       (<span class="kw">rem</span> n <span class="dv">15</span>)</span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true"></a>       n))</span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true"></a></span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> mod-cycle-buzz</span></span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true"></a>  (<span class="kw">let</span> [n  <span class="kw">identity</span></span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true"></a>        f  (<span class="kw">constantly</span> <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true"></a>        b  (<span class="kw">constantly</span> <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true"></a>        fb (<span class="kw">constantly</span> <span class="st">&quot;FizzBuzz&quot;</span>)]</span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true"></a>    (<span class="kw">cycle</span> [n n f</span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true"></a>            n b f</span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true"></a>            n n f</span>
<span id="cb32-72"><a href="#cb32-72" aria-hidden="true"></a>            b n f</span>
<span id="cb32-73"><a href="#cb32-73" aria-hidden="true"></a>            n n fb])))</span>
<span id="cb32-74"><a href="#cb32-74" aria-hidden="true"></a></span>
<span id="cb32-75"><a href="#cb32-75" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> any-mod-cycle-buzz</span></span>
<span id="cb32-76"><a href="#cb32-76" aria-hidden="true"></a>  [<span class="kw">num</span> &amp; words]</span>
<span id="cb32-77"><a href="#cb32-77" aria-hidden="true"></a>  (<span class="kw">or</span> (<span class="kw">not-empty</span> (<span class="kw">reduce</span> <span class="kw">str</span> words))</span>
<span id="cb32-78"><a href="#cb32-78" aria-hidden="true"></a>      <span class="kw">num</span>))</span>
<span id="cb32-79"><a href="#cb32-79" aria-hidden="true"></a></span>
<span id="cb32-80"><a href="#cb32-80" aria-hidden="true"></a><span class="co">;; Inspect and check the fizz-buzzes</span></span>
<span id="cb32-81"><a href="#cb32-81" aria-hidden="true"></a></span>
<span id="cb32-82"><a href="#cb32-82" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> call-all-fizz-buzzers</span></span>
<span id="cb32-83"><a href="#cb32-83" aria-hidden="true"></a>  [range-of-buzzees]</span>
<span id="cb32-84"><a href="#cb32-84" aria-hidden="true"></a>  [(fizz-buzz basic-buzz</span>
<span id="cb32-85"><a href="#cb32-85" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-86"><a href="#cb32-86" aria-hidden="true"></a>   (fizz-buzz or-buzz</span>
<span id="cb32-87"><a href="#cb32-87" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-88"><a href="#cb32-88" aria-hidden="true"></a>   (fizz-buzz juxt-buzz</span>
<span id="cb32-89"><a href="#cb32-89" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-90"><a href="#cb32-90" aria-hidden="true"></a>   (fizz-buzz or-rem15-buzz</span>
<span id="cb32-91"><a href="#cb32-91" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-92"><a href="#cb32-92" aria-hidden="true"></a>   (fizz-buzz get-rem15-buzz</span>
<span id="cb32-93"><a href="#cb32-93" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-94"><a href="#cb32-94" aria-hidden="true"></a>   (fizz-buzz (<span class="kw">fn</span> [f n] (f n))</span>
<span id="cb32-95"><a href="#cb32-95" aria-hidden="true"></a>              mod-cycle-buzz</span>
<span id="cb32-96"><a href="#cb32-96" aria-hidden="true"></a>              range-of-buzzees)</span>
<span id="cb32-97"><a href="#cb32-97" aria-hidden="true"></a>   (fizz-buzz any-mod-cycle-buzz</span>
<span id="cb32-98"><a href="#cb32-98" aria-hidden="true"></a>              range-of-buzzees</span>
<span id="cb32-99"><a href="#cb32-99" aria-hidden="true"></a>              (<span class="kw">cycle</span> [<span class="va">nil</span> <span class="va">nil</span> <span class="st">&quot;Fizz&quot;</span>])</span>
<span id="cb32-100"><a href="#cb32-100" aria-hidden="true"></a>              (<span class="kw">cycle</span> [<span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="va">nil</span> <span class="st">&quot;Buzz&quot;</span>]))])</span>
<span id="cb32-101"><a href="#cb32-101" aria-hidden="true"></a></span>
<span id="cb32-102"><a href="#cb32-102" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> check-all-fizz-buzzers</span></span>
<span id="cb32-103"><a href="#cb32-103" aria-hidden="true"></a>  <span class="st">&quot;Return true if all known fizz-buzzers produce equal results</span></span>
<span id="cb32-104"><a href="#cb32-104" aria-hidden="true"></a><span class="st">   for the programmer&#39;s FizzBuzz for numbers 1 to 100&quot;</span></span>
<span id="cb32-105"><a href="#cb32-105" aria-hidden="true"></a>  []</span>
<span id="cb32-106"><a href="#cb32-106" aria-hidden="true"></a>  (<span class="kw">apply</span> <span class="kw">=</span> (call-all-fizz-buzzers (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">101</span>))))</span></code></pre></div>
<p>And lest we forget, let us flog the dead horse one last time.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> severely-broken-buzz</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>  <span class="st">&quot;Please don&#39;t do this in Clojure.&quot;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>  [n]</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>  (<span class="kw">cond</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>    (divisible? n <span class="dv">15</span>) (<span class="kw">println</span> <span class="st">&quot;FizzBuzz&quot;</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>    (divisible? n <span class="dv">3</span>) (<span class="kw">println</span> <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>    (divisible? n <span class="dv">5</span>) (<span class="kw">println</span> <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>    <span class="at">:else</span> (<span class="kw">println</span> n)))</span></code></pre></div>
<p>The mind is abuzz drafting moaaaar variants… Stay tuned!</p>
<h1 id="peano-fizzbuzz">Peano FizzBuzz</h1>
<p>Since we are computing with natural numbers, we can express FizzBuzz in terms of the "Successor" operation of Peano arithmetic.</p>
<p>However, we have to modify our number system a bit to make it work right. We define a PeanoBuzz number to be a pair of a natural number and its FizzBuzz counterpart. The <em>PeanoBuzz</em> number system starts at <code>[0 0]</code>.</p>
<p>We can enjoy the fruits of compositionality that we planted earlier.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>(<span class="kw">ns</span> all.them.fizz.buzzers)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> rem15-&gt;fizz-buzz</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  {<span class="dv">0</span>  <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>   <span class="dv">3</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>   <span class="dv">6</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>   <span class="dv">9</span>  <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>   <span class="dv">12</span> <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>   <span class="dv">5</span>  <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>   <span class="dv">10</span> <span class="st">&quot;Buzz&quot;</span>})</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> get-rem15-buzz</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>  [n]</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>  (<span class="kw">get</span> rem15-&gt;fizz-buzz</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>       (<span class="kw">rem</span> n <span class="dv">15</span>)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a>       n))</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> S</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a>  <span class="st">&quot;The PeanoBuzz number system starting at [0 0] is closed under</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a><span class="st">  this definition of Successor.&quot;</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a>  (<span class="kw">comp</span> (<span class="kw">juxt</span> <span class="kw">identity</span> get-rem15-buzz)</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>        <span class="kw">inc</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>        <span class="kw">first</span>))</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-peano-buzzes</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a>  (<span class="kw">iterate</span> S [<span class="dv">0</span> <span class="dv">0</span>]))</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a>  (<span class="kw">=</span> (<span class="kw">take</span> <span class="dv">16</span> all-peano-buzzes)</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>     [[<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>]</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true"></a>      [<span class="dv">3</span> <span class="st">&quot;Fizz&quot;</span>] [<span class="dv">4</span> <span class="dv">4</span>]</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true"></a>      [<span class="dv">5</span> <span class="st">&quot;Buzz&quot;</span>]</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true"></a>      [<span class="dv">6</span> <span class="st">&quot;Fizz&quot;</span>] [<span class="dv">7</span> <span class="dv">7</span>] [<span class="dv">8</span> <span class="dv">8</span>]</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true"></a>      [<span class="dv">9</span> <span class="st">&quot;Fizz&quot;</span>]</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true"></a>      [<span class="dv">10</span> <span class="st">&quot;Buzz&quot;</span>] [<span class="dv">11</span> <span class="dv">11</span>]</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true"></a>      [<span class="dv">12</span> <span class="st">&quot;Fizz&quot;</span>] [<span class="dv">13</span> <span class="dv">13</span>] [<span class="dv">14</span> <span class="dv">14</span>]</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true"></a>      [<span class="dv">15</span> <span class="st">&quot;FizzBuzz&quot;</span>]]))</span></code></pre></div>
<p>Since we have a <code>S</code> that closes over the <em>PeanoBuzz</em> number system, I wonder if we can satisfy all the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano Axioms</a>? Probably another blog post :)</p>
<p>Incidentally, we can trivially map the domain of PeanoBuzz back into the domain of FizzBuzz.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>(<span class="kw">ns</span> all.them.fizz.buzzers)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>(<span class="kw">=</span> (fizz-buzz basic-buzz</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>              (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">101</span>))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>   (fizz-buzz <span class="kw">second</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>              (<span class="kw">take</span> <span class="dv">100</span> (<span class="kw">rest</span> all-peano-buzzes))))</span></code></pre></div>
<p>We are already half way to Lambda Calculus / Church Numerals. But going there will side-track our FizzBuzz expedition way too much. So I'll leave the Church Numerals version as an exercise to the reader <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>. Try to make it so that that we can define an <code>all-church-nums-buzz</code> and slot it into the <code>fizz-buzz</code> checks we already have.</p>
<h1 id="dispatch-buzz">Dispatch Buzz</h1>
<p>If you squint at the conditional FizzBuzzes, like <code>basic-buzz</code>, <code>or-buzz</code> etc., you might re-see them as a <em>dispatch</em> problem. And why would you be wrong? They, like any other if-else-y construct are truth tables hard-wired to "finalised" values or operations.</p>
<p>Naturally we will follow the consummate Clojurian's primal instinct of needing to pry apart two things masquerading as one (<em>"decomplecting"</em> <a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> in Clojurish). But, <em>what exactly</em> are we, ah, <em>decomplecting</em>? Now that is a very interesting rabbit hole.</p>
<p>In this case we are <em>"separating mechanism from policy"</em> <a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>. Figuring out how to do this delivers a powerful, flexible method of program design into our eager hands.</p>
<p>This table shows "mechanism" and "policy" hard-wired together.</p>
<pre class="org"><code>&lt;-- ------- MECHANISM -------- --&gt;|&lt;-- POLICY --&gt;

| n divisible? 3 | n divisible? 5 | Final value |
|----------------+----------------+-------------|
| true           | true           | FizzBuzz    |
| true           | false          | Fizz        |
| false          | true           | Buzz        |
| false          | false          | n           |
</code></pre>
<p>Here is an attempt to pry the two apart.</p>
<p><em><strong>Mechanism</strong></em></p>
<p>The <em><strong>"mechanism"</strong></em> here is <em>any</em> function that translates a number (or more generally, <em>any</em> thing) to the two inputs of a 2-value truth table. We can see it more clearly if we rewrite the input columns of the truth table like this. Here <code>f</code> and <code>g</code> are functions of <code>a</code> to Boolean.</p>
<pre class="org"><code>| (f a) | (g a) |
|-------+-------|
| true  | true  |
| true  | false |
| false | true  |
| false | false |
</code></pre>
<p>We can express this as a Clojure punction 'coz (f a) (g a) is ((juxt f g) a).</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>(<span class="kw">ns</span> dispatch.buzz)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> mechanism</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>  <span class="st">&quot;Given two functions, presumably of anything -to-&gt; Boolean, return</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a><span class="st">  a function that can construct inputs of a 2-input truth table.&quot;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a>  [f? g?]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>  (<span class="kw">juxt</span> f? g?))</span></code></pre></div>
<p>See? Such abstract. Much general-purpose. Very decomplect. Wow.</p>
<p><em><strong>Policy</strong></em></p>
<p>Here, we define <em><strong>"policy"</strong></em> as something having special context of FizzBuzz that consumes input rows of the truth table and emits corresponding output fields.</p>
<p>First, we specialise the abstract <code>mechanism</code> to a FizzBuzz mechanism. You may smirk <a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>, but just you wait. There is a (multi) method to the madness…</p>
<p>Here is the table we started with, rewritten for our specialisation.</p>
<pre class="org"><code>| (fizzes? n) | (buzzes? n) | (mechanism fizzes? buzzes?) -&gt; mfb |
|-------------+-------------+------------------------------------|
| true        | true        | (mfb n) =&gt; &quot;FizzBuzz&quot;              |
| true        | false       | (mfb n) =&gt; &quot;Fizz&quot;                  |
| false       | true        | (mfb n) =&gt; &quot;Buzz&quot;                  |
| false       | false       | (mfb n) =&gt; n                       |
</code></pre>
<p>Here is the intermediate step of the specialisation, viz. <code>(mechanism f g) -&gt; h</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>(<span class="kw">ns</span> dispatch.buzz)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> divisible?</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>  [divisor n]</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>  (<span class="kw">zero?</span> (<span class="kw">rem</span> n divisor)))</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">3</span>))</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> buzzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">5</span>))</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true"></a><span class="co">;; If we take the abstract mechanism and give it functions</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true"></a><span class="co">;; that test numbers for fizzery and buzzery, then we can</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true"></a><span class="co">;; construct a version of the truth table that is /concretely/</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true"></a><span class="co">;; specific to FizzBuzz.</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true"></a>  (<span class="kw">=</span> (<span class="kw">map</span> (mechanism fizzes? buzzes?)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true"></a>          [<span class="dv">15</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span>])</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true"></a>     [[<span class="va">true</span> <span class="va">true</span>]</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true"></a>      [<span class="va">true</span> <span class="va">false</span>]</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true"></a>      [<span class="va">false</span> <span class="va">true</span>]</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true"></a>      [<span class="va">false</span> <span class="va">false</span>]])</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Finally, we hang it all together with Clojure's multimethods <a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>, like so.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>(<span class="kw">ns</span> dispatch.buzz)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz </span><span class="kw">map</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz-mechanism</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  (mechanism fizzes? buzzes?))</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a>(<span class="bu">defmulti</span><span class="fu"> dispatch-buzz</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>  <span class="st">&quot;It yields the third column of the truth table.&quot;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a>  fizz-buzz-mechanism)</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a><span class="co">;; The /Policy/, fully realised.</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true"></a><span class="co">;; ((mechanism fizzes? buzzes?) n) -&gt; final results</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> dispatch-buzz </span>[<span class="va">true</span> <span class="va">true</span>]</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true"></a>  [n]</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true"></a>  <span class="st">&quot;FizzBuzz&quot;</span>)</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true"></a></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> dispatch-buzz </span>[<span class="va">true</span> <span class="va">false</span>]</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true"></a>  [n]</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true"></a>  <span class="st">&quot;Fizz&quot;</span>)</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true"></a></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> dispatch-buzz </span>[<span class="va">false</span> <span class="va">true</span>]</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true"></a>  [n]</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true"></a>  <span class="st">&quot;Buzz&quot;</span>)</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true"></a></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true"></a>(<span class="bu">defmethod</span><span class="fu"> dispatch-buzz </span><span class="at">:default</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true"></a>  [n]</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true"></a>  n)</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true"></a></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true"></a><span class="co">;; The /Policy/, applied.</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true"></a>  (<span class="kw">=</span> (fizz-buzz dispatch-buzz</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true"></a>                [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">16</span>])</span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true"></a>     [<span class="dv">1</span> <span class="st">&quot;Fizz&quot;</span> <span class="st">&quot;Buzz&quot;</span> <span class="st">&quot;FizzBuzz&quot;</span> <span class="dv">16</span>])</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Yes, 'tis a wee FizzBuzz interpreter!</p>
<p>(Pirouettes off-stage, gracefully.)</p>
<h1 id="embarrassingly-parallel-fizzbuzz">Embarrassingly Parallel FizzBuzz</h1>
<p>It turns out FizzBuzz is one of those so-called <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">Embarrassingly Parallel</a> problems.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>(<span class="kw">ns</span> all.them.fizz.buzzers)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz </span><span class="kw">map</span>)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a><span class="co">;; Add 1 character for parallel map.</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> embarrassingly-parallel-fizz-buzz </span><span class="kw">pmap</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>  (<span class="kw">let</span> [range-of-buzzees (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">101</span>)]</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a>    (<span class="kw">=</span> (fizz-buzz basic-buzz</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a>                  range-of-buzzees)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true"></a>       (embarrassingly-parallel-fizz-buzz basic-buzz</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true"></a>                                          range-of-buzzees)))</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true"></a>  )</span></code></pre></div>
<p>I was almost too embarrassed to write this, but I'm glad good sense prevailed, because the trivial replacement of <code>map</code> with <code>pmap</code> teaches a lesson.</p>
<p>Parallelism is impossibly hard if we don't have pure functions, immutability, and laziness. When we do, it reduces to merely hard but tractable. The proverbial single character code modification (in this case, literally so) gets a free ride on those other constructs.</p>
<p>We can see it in <code>pmap</code>'s implementation. It is fairly straightforward. Fetch its source and stare at it for a bit; <code>(clojure.repl/source pmap)</code>. You will be able to make sense of it with a bit of cross-referencing ClojureDocs.</p>
<p>If your favourite language has something similar (parallel version of a sequential function), and if you choose to compare implementations, I will be delighted to learn from your analysis!</p>
<h1 id="oop-buzz">OOP Buzz</h1>
<p>What is an Object in, say, Java? It is a combination of four distinct things:</p>
<ul>
<li>Name (Class name / Java type)</li>
<li>Structure (Class members, methods etc.)</li>
<li>Behaviour (effects caused by methods)</li>
<li>State (contained in the run-time instance of the Class)</li>
</ul>
<p>In Clojure, <em>all of these are separate</em> ("available a la carte", in Clojurish), the consequences of which are hard to explain sans a motivating example.</p>
<p>Clojure's approach to Polymorphism allow us to do things like this.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>(<span class="kw">ns</span> oops.fizzbuzz)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> divisible? </span>(<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>))</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz </span><span class="kw">map</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a><span class="co">;; Like a Java Interface, but better.</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>(<span class="bu">defprotocol</span><span class="fu"> IFizzBuzz</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>  (proto-buzz [this]))</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true"></a><span class="co">;; We can add new behaviour to existing types,</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true"></a><span class="co">;; including /any/ Java built-in type.</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true"></a>(<span class="kw">extend-protocol</span> IFizzBuzz</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true"></a>  java.lang.Number</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true"></a>  (proto-buzz [this]</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true"></a>      (divisible? this <span class="dv">15</span>) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true"></a>      (divisible? this <span class="dv">3</span>) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true"></a>      (divisible? this <span class="dv">5</span>) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true"></a>      <span class="at">:else</span> this)))</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true"></a></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true"></a>  <span class="co">;; Now we can do this</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true"></a>  (<span class="kw">=</span> (fizz-buzz proto-buzz</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true"></a>                [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">16</span>])</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true"></a>     [<span class="dv">1</span> <span class="st">&quot;Fizz&quot;</span> <span class="st">&quot;Buzz&quot;</span> <span class="st">&quot;FizzBuzz&quot;</span> <span class="dv">16</span>])</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true"></a></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true"></a>  <span class="co">;; And we can also do this</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true"></a>  (<span class="kw">=</span> (fizz-buzz proto-buzz</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true"></a>                [<span class="fl">1.0</span> <span class="fl">3.0</span> <span class="fl">5.0</span> <span class="fl">15.0</span> <span class="fl">15.9</span>])</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true"></a>     [<span class="fl">1.0</span> <span class="st">&quot;Fizz&quot;</span> <span class="st">&quot;Buzz&quot;</span> <span class="st">&quot;FizzBuzz&quot;</span> <span class="fl">15.9</span>])</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true"></a></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true"></a>  <span class="co">;; WITHOUT breaking any existing Equality semantics.</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true"></a>  <span class="co">;; (= 42 42) =&gt; true (long and long)</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true"></a>  <span class="co">;; (= 42 42.0) =&gt; false (long and double)</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true"></a>  <span class="co">;; (= 42.0 42.0) =&gt; true (double and double)</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true"></a></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true"></a>  <span class="co">;; Thus, this is false, as it should be.</span></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true"></a>  (<span class="kw">=</span> (fizz-buzz proto-buzz</span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true"></a>                [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="dv">16</span>])</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true"></a>     (fizz-buzz proto-buzz</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true"></a>                [<span class="fl">1.0</span> <span class="fl">3.0</span> <span class="fl">5.0</span> <span class="fl">15.0</span> <span class="fl">15.9</span>]))</span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Not to put too fine a point on it, but Clojure is a <em>far more capable</em> Object Oriented Programming System than say Java or Kotlin, a fact which I have personally profited from handsomely in the past <a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>.</p>
<p>Why?</p>
<p>In short, Clojure cleanly solves the "<a href="https://en.wikipedia.org/wiki/Expression_problem">Expression Problem</a>".</p>
<p>In long, you can…</p>
<ul>
<li>Watch <a href="https://www.youtube.com/watch?v=kQhOlWXXl2I">Clojure Protocols Explained</a>, by Sean Devlin.</li>
<li>Watch <a href="https://www.infoq.com/presentations/Clojure-Expression-Problem/">Clojure's Solutions to the Expression Problem</a>, by Chris Houser.</li>
<li>Listen to <a href="https://www.infoq.com/interviews/hickey-clojure-protocols/">Rich Hickey on Protocols and Clojure 1.3</a>, by Rich Hickey.</li>
<li>Read "<a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f">Rich Already Answered That!</a>", curated by reborg. <em>"A list of commonly asked questions, design decisions, reasons why Clojure is the way it is as they were answered directly by Rich."</em></li>
<li>Read the parable of <a href="https://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html">The venerable master Qc Na and his student Anton</a>. This <a href="https://news.ycombinator.com/item?id=14235020">HN thread</a> also has some interesting links (and diatribes).</li>
</ul>
<p>In <em>very</em> short… Tweet this, look smart, get paid!</p>
<blockquote>
<p><em>If you do Functional Programming right, you get Object Oriented Programming for free #Clojure. (And vice-versa e.g. #Erlang #Smalltalk #OCaml).</em></p>
<ul>
<li>Yours Truly</li>
</ul>
</blockquote>
<h1 id="non-destructive-fizzbuzz">Non-Destructive FizzBuzz</h1>
<p><code>proto-buzz</code> is a great motivating example of what I would like to call the <em><strong>Non-Destructive</strong></em> FizzBuzz.</p>
<p>All the FizzBuzz solutions seen previously, except PeanoBuzz, lose information. This is almost always bad because its impossible to reverse information loss. The inverse is also true. It is almost always good to <em>augment</em> information. Prefer to enrich information and retain as much as resources permit (organised neatly, of course). Ask any lawyer or accountant or friendly neighbourhood Clojurian which alternative would set their hair on fire.</p>
<p>Here I play with some more ways to FizzBuzz non-destructively.</p>
<p>As I do, I meditate upon the extra super nice thing about <code>proto-buzz</code>. Which is that we did <em>not</em> have to invent a new number system or box numbers in some composite FizzBuzz data representation <em>and</em> we lost no functionality — numbers still behave exactly as we expect, with zero added overhead!</p>
<h2 id="composite-data-buzz">Composite Data Buzz</h2>
<p>PeanoBuzz was an example of writing FizzBuzz in terms of "composite" data. Abstractly, that idea is basically "attach some meta-data to my things".</p>
<p>PeanoBuzz was a tuple <code>[3 "Fizz"]</code>, but it could very well have been a custom map representation, say, <code>{:n 3 :fizzbuzz "Fizz"}</code>.</p>
<p>We can do one better by using Clojure Records to attach full-blooded Java types to our numbers <a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> <em>and also</em> make "composite" data, because Records give us all the features of generic hash-maps for free.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>(<span class="kw">ns</span> boxed.fizz.buzz)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> divisible? </span>(<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz </span><span class="kw">map</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>(<span class="bu">defrecord</span><span class="fu"> Fizz </span>[n])</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a>(<span class="bu">defrecord</span><span class="fu"> Buzz </span>[n])</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>(<span class="bu">defrecord</span><span class="fu"> FizzBuzz </span>[n])</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true"></a>(<span class="bu">defrecord</span><span class="fu"> Identity </span>[n])</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> boxed-buzz</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true"></a>  [n]</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true"></a>  (<span class="kw">cond</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true"></a>    (divisible? n <span class="dv">15</span>) (-&gt;FizzBuzz n)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true"></a>    (divisible? n <span class="dv">3</span>) (-&gt;Fizz n)</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true"></a>    (divisible? n <span class="dv">5</span>) (-&gt;Buzz n)</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true"></a>    <span class="at">:else</span> (-&gt;Identity n)))</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true"></a></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-boxed-buzzes</span></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true"></a>  (<span class="kw">map</span> boxed-buzz</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true"></a>       (<span class="kw">rest</span> (<span class="kw">range</span>))))</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true"></a>  <span class="co">;; Composite hash-map-like data!</span></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true"></a>  (<span class="kw">=</span> (fizz-buzz boxed-buzz</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true"></a>                [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span>])</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true"></a>     [#boxed.fizz.buzz.Identity{<span class="at">:n</span> <span class="dv">1</span>}</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true"></a>      #boxed.fizz.buzz.Fizz{<span class="at">:n</span> <span class="dv">3</span>}</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true"></a>      #boxed.fizz.buzz.Buzz{<span class="at">:n</span> <span class="dv">5</span>}</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true"></a>      #boxed.fizz.buzz.FizzBuzz{<span class="at">:n</span> <span class="dv">15</span>}]) <span class="co">; =&gt; true</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true"></a></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true"></a>  <span class="co">;; Which is nondestructive!</span></span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true"></a>  (<span class="kw">=</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span>]</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true"></a>     (fizz-buzz (<span class="kw">comp</span> <span class="at">:n</span> boxed-buzz)</span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true"></a>                [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span>])) <span class="co">; =&gt; true</span></span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true"></a></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true"></a>  <span class="co">;; And which has real Java types!</span></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true"></a>  (<span class="kw">=</span> (<span class="kw">map</span> <span class="kw">type</span> (fizz-buzz boxed-buzz [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span>]))</span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true"></a>     [boxed.fizz.buzz.Identity</span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true"></a>      boxed.fizz.buzz.Fizz</span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true"></a>      boxed.fizz.buzz.Buzz</span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true"></a>      boxed.fizz.buzz.FizzBuzz]) <span class="co">; =&gt; true</span></span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Further exercises for the dear reader!</p>
<ul>
<li>Re-implement PeanoBuzz using Clojure hash-maps!</li>
<li>Re-re-implement PeanoBuzz with Records!</li>
<li><em>Separately</em> write something that can return the classic string-or-number equivalent of your composite types! (Hint: use multimethods and/or protocols as appropriate).</li>
</ul>
<p>Last but not least, ask yourself "But what about equality? And the rest of arithmetic?" while comparing these with <code>proto-buzz</code>.</p>
<h2 id="clojure-specd-buzz">Clojure Spec'd Buzz</h2>
<p>Off-label use of <a href="https://clojure.org/guides/spec">Clojure Spec</a>'s <code>conform</code> as a parser can be very handy.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>(<span class="kw">ns</span> conformer.buzz)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>(<span class="kw">require</span> &#39;[clojure.spec.alpha <span class="at">:as</span> s])</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> divisible?</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>  [divisor n]</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>  (<span class="kw">zero?</span> (<span class="kw">rem</span> n divisor)))</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">3</span>))</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> buzzes? </span>(<span class="kw">partial</span> divisible? <span class="dv">5</span>))</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a>(s/def <span class="at">::number</span> <span class="kw">number?</span>)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a>(s/def <span class="at">::fizzes</span> (s/and <span class="at">::number</span> fizzes?))</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a>(s/def <span class="at">::buzzes</span> (s/and <span class="at">::number</span> buzzes?))</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true"></a>  <span class="co">;; Now we can parse input data...</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true"></a>  (s/conform <span class="at">::fizzes</span> <span class="dv">3</span>) <span class="co">; =&gt; 3</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true"></a>  (s/conform <span class="at">::buzzes</span> <span class="dv">5</span>) <span class="co">; =&gt; 5</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true"></a>  (s/conform <span class="at">::buzzes</span> <span class="dv">3</span>) <span class="co">; =&gt; :clojure.spec.alpha/invalid</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true"></a>  (s/conform (s/and <span class="at">::fizzes</span> <span class="at">::buzzes</span>) <span class="dv">15</span>) <span class="co">; =&gt; 15</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true"></a></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true"></a>  <span class="co">;; And we can handle non-conforming data gracefully,</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true"></a>  <span class="co">;; instead of panicking and throwing exceptions.</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true"></a>  (s/conform (s/or <span class="at">::fizzes</span> <span class="at">::buzzes</span>) <span class="st">&quot;lol&quot;</span>) <span class="co">; :clojure.spec.alpha/invalid</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true"></a>  )</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true"></a></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz-specs</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true"></a>  <span class="st">&quot;Set of FizzBuzz parsers.&quot;</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true"></a>  #{<span class="at">::fizzes</span> <span class="at">::buzzes</span> <span class="at">::number</span>})</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true"></a></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> spec-parse-buzz</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true"></a>  <span class="st">&quot;Conform the given input to the set of specs for fizz-buzz, and return</span></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true"></a><span class="st">  a pair of the input and a map of parsed values keyed by the parser name.&quot;</span></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true"></a>  [x]</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true"></a>  [x (<span class="kw">zipmap</span> fizz-buzz-specs</span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true"></a>             (<span class="kw">map</span> #(s/conform <span class="va">%</span> x) fizz-buzz-specs))])</span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true"></a></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> all-spec-buzzes</span></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true"></a>  (<span class="kw">map</span> spec-parse-buzz</span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true"></a>       (<span class="kw">rest</span> (<span class="kw">range</span>))))</span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true"></a></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true"></a>  <span class="co">;; And we can...</span></span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true"></a>  (<span class="kw">take</span> <span class="dv">100</span> all-spec-buzzes)</span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true"></a></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true"></a>  <span class="co">;; Which gives us enriched data, like this:</span></span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true"></a>  (<span class="kw">=</span> (<span class="kw">into</span> {} (<span class="kw">map</span> spec-parse-buzz [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span> <span class="st">&quot;lol&quot;</span>]))</span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true"></a>     {<span class="dv">1</span> #<span class="at">:conformer.buzz</span>{<span class="at">:fizzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true"></a>                         <span class="at">:buzzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true"></a>                         <span class="at">:number</span> <span class="dv">1</span>},</span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true"></a>      <span class="dv">3</span> #<span class="at">:conformer.buzz</span>{<span class="at">:fizzes</span> <span class="dv">3</span>,</span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true"></a>                         <span class="at">:buzzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true"></a>                         <span class="at">:number</span> <span class="dv">3</span>},</span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true"></a>      <span class="dv">5</span> #<span class="at">:conformer.buzz</span>{<span class="at">:fizzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true"></a>                         <span class="at">:buzzes</span> <span class="dv">5</span>,</span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true"></a>                         <span class="at">:number</span> <span class="dv">5</span>},</span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true"></a>      <span class="dv">15</span> #<span class="at">:conformer.buzz</span>{<span class="at">:fizzes</span> <span class="dv">15</span>,</span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true"></a>                          <span class="at">:buzzes</span> <span class="dv">15</span>,</span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true"></a>                          <span class="at">:number</span> <span class="dv">15</span>},</span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true"></a>      <span class="st">&quot;lol&quot;</span> #<span class="at">:conformer.buzz</span>{<span class="at">:fizzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true"></a>                             <span class="at">:buzzes</span> <span class="at">:clojure.spec.alpha/invalid</span>,</span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true"></a>                             <span class="at">:number</span> <span class="at">:clojure.spec.alpha/invalid</span>}}) <span class="co">; =&gt; true</span></span>
<span id="cb45-63"><a href="#cb45-63" aria-hidden="true"></a> )</span></code></pre></div>
<p>However, like off-label use of anything, this <code>conform</code>-as-parser trick too skirts the "can be a very bad idea" territory.</p>
<p>YMMV.</p>
<h2 id="wicked-pprint-buzz">Wicked pprint Buzz</h2>
<p><a href="https://twitter.com/rdivyanshu"><span class="citation" data-cites="rdivyanshu">@rdivyanshu</span></a> said to add this extra <a href="https://github.com/clojure/clojure/blob/b1b88dd25373a86e41310a525a21b497799dbbf2/src/clj/clojure/pprint/dispatch.clj#L175">pprint dispatcher</a>, <em>"and let no number escape fizzbuzzness when showing itself"</em>.</p>
<p>Why not?</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>(<span class="kw">ns</span> pprint.buzz)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>(<span class="kw">require</span> &#39;[clojure.pprint <span class="at">:as</span> pp])</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> pprint-buzz</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>  [n]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>  (<span class="kw">let</span> [divisible? (<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>        prettyprint (<span class="kw">comp</span> <span class="kw">prn</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>                          (<span class="kw">partial</span> <span class="kw">format</span> <span class="st">&quot;%d doth %s&quot;</span>))]</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a>    (<span class="kw">cond</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a>      (divisible? n <span class="dv">15</span>) (prettyprint n <span class="st">&quot;FizzBuzzeth&quot;</span>)</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true"></a>      (divisible? n <span class="dv">3</span>) (prettyprint n <span class="st">&quot;Fizzeth&quot;</span>)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true"></a>      (divisible? n <span class="dv">5</span>) (prettyprint n <span class="st">&quot;Buzzeth&quot;</span>)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true"></a>      <span class="at">:else</span> (prettyprint n <span class="st">&quot;not Fizzeth nor Buzzeth. Alas!&quot;</span>))))</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true"></a>  <span class="co">;; lol</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true"></a>  (<span class="va">#&#39;pp/use-method</span> pp/simple-dispatch java.lang.Number pprint-buzz)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true"></a></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true"></a>  <span class="co">;; nothing to see here... you will have to look at the REPL</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true"></a>  (<span class="kw">doseq</span> [n [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">15</span>]]</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true"></a>    (pp/pprint n)) <span class="co">;; lol lol lol lolllll</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true"></a>  )</span></code></pre></div>
<p>You, Sir, are truly a gentlenerd and a scholar.</p>
<p>Nondestructive, and hilarious to boot!</p>
<h2 id="tagged-literal-buzz">Tagged Literal Buzz</h2>
<p>Thinking aloud…</p>
<p>Clojure has a concept of "tagged literals"; plaintext labels that we can "attach" to data <em>without</em> changing the literal value of our data, <em>and</em> transmit over wires along with the data.</p>
<p>Clojure provides built-in support for a small set of some fairly universal types of literals (instant, UUID etc.). And I have used fancier tagged literals, but only in context of other people's libraries (<a href="https://github.com/juxt/aero">juxt/aero</a>).</p>
<p>How to make this work, I wonder?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>(<span class="kw">ns</span> tagged.buzz)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a><span class="co">;; We can do this, but how to work with it?</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>(set! *default-data-reader-fn* tagged-literal)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> tagged-buzz</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>  #tagged.buzz/FizzBuzzSequence [#tagged.buzz/Fizz <span class="dv">3</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a>                                 #tagged.buzz/Buzz <span class="dv">5</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a>                                 #tagged.buzz/FizzBuzz <span class="dv">15</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>                                 #tagged.buzz/Number <span class="dv">1</span>])</span></code></pre></div>
<p>Note: Parked for now. I'm not sure if this a reasonably real-world FizzBuzz.</p>
<h1 id="interlude-what-more-could-we-possibly-decomplect">Interlude: What more could we possibly decomplect?</h1>
<p>Well, in one word, <em><strong>Transducers</strong></em>.</p>
<p>Which you can assume is Clojurish for "You haven't decomplected your Clojure quite enough just yet.". But before we go there, a quick survey.</p>
<p>Thus far, we have pulled apart the FizzBuzz problem space in many dimensions.</p>
<ul>
<li>Calculation v/s Effects (lifted out <code>println</code>)</li>
<li>Calculation v/s Sequence generation (lifted fizzbuzz logic out of <code>for</code>)</li>
<li>Definition v/s Realisation (lazy definitions like <code>all-fizz-buzzes</code>)</li>
<li>Lifted out concepts in the domain of the <em>solution</em> (<code>fizzes?</code> <code>buzzes?</code> etc.)</li>
<li>Lifted out concepts in the domain of the <em>problem</em> (modulo math FizzBuzzes)</li>
<li>Lifted all fizzbuzzes out of the concrete 3/5 FizzBuzz (<code>any-mod-cycle-buzz</code>)</li>
<li>Added Fizzbuzz-meaning to Numbers <em>without</em> changing existing Number-meaning (protocols, and maybe also tagged literals if I can make it work sensibly)</li>
<li>Concrete Numbers v/s abstract representations (PeanoBuzz, <code>mod-cycle-buzz</code>)</li>
<li>Calculation v/s Specification (<code>spec-parse-buzz</code>)</li>
<li>We even teased apart <em>printing context</em> (wicked <code>pprint-buzz</code>)</li>
</ul>
<p>Note that <em><strong>all of this belongs in the real-world Clojurian's design toolbox</strong>.</em></p>
<p>Not only do we do it "in the small", in our little namespaces and <del>monoliths</del> polyliths, we also do it "in the large" in our data-center-spanning distributed systems.</p>
<p>But you see, in all the teasing apart so far, we <em>implied</em> FizzBuzz was in-memory sequence processing. What if we <em>could not make any assumption whatsoever</em> about data source, or data size, or data format, or process control, or the output sink? Can we still describe FizzBuzz in some useful way?</p>
<p>Well, in one word, <em><strong>Transducers</strong></em>.</p>
<p>Savvy Clojurians may appreciate that text above has <a href="https://clojure.org/reference/transducers#_terminology">transducer signature</a>.</p>
<blockquote>
<p>(whatever, input -&gt; whatever) -&gt; (whatever, input -&gt; whatever)</p>
<p>"<a href="https://www.youtube.com/watch?v=6mTbuzafcII&amp;t=1677s">Seems like a good project for the bar, later on.</a>"</p>
<ul>
<li>Rich Hickey</li>
</ul>
</blockquote>
<h1 id="transducery-buzz">Transducery Buzz</h1>
<p>This is really my feeble attempt to nerdsnipe you into falling into deep abstraction territory.</p>
<p>I pray that you give yourself time to <em>absorb</em> transducers. Peruse the code below. Then peruse the list of stimulating material that follows, over a relaxed weekend with several cups of delicious artisanal Oolong to salve the brain pain.</p>
<h2 id="what-are-we-decomplecting">What are we decomplecting?</h2>
<p>Because, with <em><strong>transducers</strong></em>, we will now <em>also</em> pull apart:</p>
<ul>
<li>Data source (sequence, stream, channel, socket etc.)</li>
<li>Data sink (sequence, stream, channel, socket etc.)</li>
<li>Data transformer (function of any value -&gt; any other value)</li>
<li>Data transformation process (mapping, filtering, reducing etc.)</li>
<li>Some process control (we can transduce finite data (of course) as well as streams, and also have optional early termination in either case. I'm not sure about first-class support for other methods like backpressure.)</li>
</ul>
<p>Of course, for useful computations, we have to compose these back in some sensible way, appropriate to the context at hand (e.g. read numbers off a Kafka topic, FizzBuzz them, and send them to another Kafka topic, OR slurp numbers from file on disk, FizzBuzz them, and push into an in-memory queue).</p>
<p>A word of caution. As you read, you may think "Ew, he peddles oldass Unix Pipes." <a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> (or shiny new Monads or Lambda Architecture(TM) or some familiar-to-you generics). You won't be <em>wrong</em>. You won't be <em>right</em> either.</p>
<p>Because, as is true for all sufficiently abstract abstractions, analogies are not equivalences. Details differ deeply and your brain will hurt at first. A lot. For example, it is <em>not</em> obvious <em>why</em>, but the transducer's mandate of <em>a la carte</em> re-composition <em>demands</em> that <em>all</em> the new pulling apart <em>must be fully compatible</em> with <em>all</em> the old pulling apart.</p>
<p>'nuff said. Decomplecting our Clojure 'smore in 3… 2… 1…</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>(<span class="kw">ns</span> transducery.buzz)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> divisible?</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>  (<span class="kw">comp</span> <span class="kw">zero?</span> <span class="kw">rem</span>))</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> basic-buzz</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>  [n]</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a>  (<span class="kw">cond</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true"></a>    (divisible? n <span class="dv">15</span>) <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true"></a>    (divisible? n <span class="dv">3</span>) <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true"></a>    (divisible? n <span class="dv">5</span>) <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true"></a>    <span class="at">:else</span> n))</span></code></pre></div>
<p>zzzzz. snort. Old news. Whatever.</p>
<h2 id="demo-one-computation-and-output-format-pulled-apart">Demo One: Computation and <em>Output</em> format pulled apart</h2>
<div class="sourceCode" id="cb49"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>(<span class="kw">ns</span> transducery.buzz)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a><span class="co">;; Separately define /only/ the transformation &quot;xform&quot;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> fizz-buzz-xform</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>  (<span class="kw">comp</span> (<span class="kw">map</span> basic-buzz)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>        (<span class="kw">take</span> <span class="dv">100</span>))) <span class="co">;; early termination</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true"></a><span class="co">;; Separately define /only/ input data</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> natural-nums</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true"></a>  (<span class="kw">rest</span> (<span class="kw">range</span>)))</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true"></a></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true"></a><span class="co">;; Compose to produce a sequence</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true"></a>  (transduce fizz-buzz-xform <span class="co">;; calculate each step</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true"></a>             <span class="kw">conj</span> <span class="co">;; and use this output method</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true"></a>             []   <span class="co">;; to pour output into this data structure</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true"></a>             natural-nums) <span class="co">;; given this input</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true"></a>  )</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true"></a></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true"></a><span class="co">;; Compose differently to produce a string</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true"></a>  (transduce fizz-buzz-xform <span class="co">;; calculate each step</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true"></a>             <span class="kw">str</span> <span class="co">;; and use this output method</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true"></a>             <span class="st">&quot;&quot;</span>  <span class="co">;; to catenate output into this string</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true"></a>             natural-nums) <span class="co">;; given this input</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true"></a>  )</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true"></a></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true"></a><span class="co">;; Compose still differently to produce a CSV string</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true"></a>(<span class="bu">defn</span><span class="fu"> suffix-comma</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true"></a>  [s]</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true"></a>  (<span class="kw">str</span> s <span class="st">&quot;,&quot;</span>))</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true"></a></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true"></a>  (transduce (<span class="kw">comp</span> fizz-buzz-xform</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true"></a>                   (<span class="kw">map</span> suffix-comma)) <span class="co">;; calculate each step</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true"></a>             <span class="kw">str</span> <span class="co">;; and use this output method</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true"></a>             <span class="st">&quot;&quot;</span>  <span class="co">;; to catenate output into this string</span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true"></a>             natural-nums) <span class="co">;; given this input</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true"></a>  )</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true"></a></span></code></pre></div>
<p>Pause for a bit.</p>
<ul>
<li>Consider the parts we did <em>not</em> have to modify <em>at all</em> even though we modified <em>everything</em> about the output and about the xform.</li>
<li>Consider what it might take to reuse any of the other fizzbuzzers instead of <code>basic-buzz</code>.</li>
<li>Try it!</li>
</ul>
<h2 id="demo-two-computation-and-input-format-pulled-apart.">Demo Two: Computation and <em>Input</em> format pulled apart.</h2>
<div class="sourceCode" id="cb50"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>(<span class="kw">ns</span> transducery.buzz)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a><span class="co">;; Setup</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>(<span class="bu">def</span><span class="fu"> numbers-file</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  <span class="st">&quot;Plaintext file containing numbers in some format.&quot;</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>  <span class="st">&quot;/tmp/deleteme-spat-by-clj-fizz-buzz-demo.txt&quot;</span>)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a><span class="co">;; Write 10,000 natural numbers to file, one per line</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a><span class="co">#_</span>(spit numbers-file</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>        (clojure.string/join <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> (<span class="kw">range</span> <span class="dv">1</span> <span class="dv">10001</span>)))</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a><span class="co">;; Read back to double-check we got it.</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true"></a><span class="co">#_</span>(<span class="kw">slurp</span> numbers-file)</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true"></a></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true"></a></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true"></a><span class="co">;; For contrast: This is how we might fizz-buzz traditionally.</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true"></a>  <span class="co">;; Like this, if we don&#39;t know our threading macros.</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true"></a>  <span class="co">;; (Don&#39;t fret about it. This is just fine.)</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true"></a>  (<span class="kw">let</span> [fizz-buzz (<span class="kw">fn</span> [s] (basic-buzz (Integer/parseInt s)))]</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true"></a>    (<span class="kw">take</span> <span class="dv">15</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true"></a>          (<span class="kw">map</span> fizz-buzz</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true"></a>               (clojure.string/split-lines (<span class="kw">slurp</span> numbers-file)))))</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true"></a></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true"></a></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true"></a>  <span class="co">;; Or more Clojurishly, with our nifty threading macros.</span></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true"></a>  (<span class="kw">-&gt;&gt;</span> numbers-file</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true"></a>       <span class="kw">slurp</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true"></a>       clojure.string/split-lines</span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true"></a>       (<span class="kw">map</span> #(basic-buzz (Integer/parseInt <span class="va">%</span>)))</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true"></a>       (<span class="kw">take</span> <span class="dv">15</span>))</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true"></a>  <span class="co">;; I interrupted us with this, because of a pet peeve. People like to</span></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true"></a>  <span class="co">;; describe this form as a &quot;pipeline&quot;. It isn&#39;t. It is a formatting</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true"></a>  <span class="co">;; sleight of hand that makes in-process call stacks of functions</span></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true"></a>  <span class="co">;; /appear/ to be straight-line. The resulting shape visually suggests</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true"></a>  <span class="co">;; punching data through a pipeline.</span></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true"></a>  <span class="co">;;</span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true"></a>  <span class="co">;; Whereas pipelines are fundamentally streaming abstractions that</span></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true"></a>  <span class="co">;; cross process boundaries.</span></span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true"></a>  <span class="co">;;</span></span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true"></a>  <span class="co">;; Transducers + xforms are highly pipeline-like.</span></span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true"></a>  )</span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true"></a></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true"></a><span class="co">;; Apart from not really being pipelines, both these traditional versions</span></span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true"></a><span class="co">;; are also hopelessly complected with sequences, which malady is addressed</span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true"></a><span class="co">;; by this transducer version.</span></span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true"></a>(<span class="kw">comment</span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true"></a>  (transduce (<span class="kw">comp</span> (<span class="kw">map</span> #(Integer/parseInt <span class="va">%</span>))</span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true"></a>                   fizz-buzz-xform) <span class="co">;; calculate each step</span></span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true"></a>             <span class="kw">conj</span> <span class="co">;; and use this output method</span></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true"></a>             []   <span class="co">;; to pour output into this data structure</span></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true"></a>             (clojure.string/split-lines</span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true"></a>              (<span class="kw">slurp</span> numbers-file))) <span class="co">;; given this input</span></span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true"></a>  )</span></code></pre></div>
<p>A reader may complain that split-lines and file slurpin' is still complected. The reader would be right. Tim Baldridge's video series listed below will help work out how one might go about transducing over numbers-file directly.</p>
<h2 id="demo-three-use-only-the-xform-as-a-calculator">Demo Three: Use <em>only</em> the xform as a calculator</h2>
<div class="sourceCode" id="cb51"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>(<span class="kw">ns</span> transducery.buzz)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a><span class="co">;; The xform can still calculate just a single item:</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>((fizz-buzz-xform <span class="kw">conj</span>) [] <span class="dv">3</span>) <span class="co">;; =&gt; [&quot;Fizz&quot;]</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>((fizz-buzz-xform <span class="kw">str</span>) <span class="st">&quot;&quot;</span> <span class="dv">3</span>) <span class="co">;; =&gt; &quot;Fizz&quot;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>((fizz-buzz-xform <span class="kw">str</span>) <span class="st">&quot;&quot;</span> <span class="dv">1</span>) <span class="co">;; =&gt; &quot;1&quot;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>((fizz-buzz-xform (<span class="kw">fn</span> [_ out] out)) <span class="va">nil</span> <span class="dv">3</span>) <span class="co">;; &quot;Fizz&quot;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>((fizz-buzz-xform (<span class="kw">fn</span> [_ out] out)) <span class="va">nil</span> <span class="dv">1</span>) <span class="co">;; 1</span></span></code></pre></div>
<p>Hopefully now it is a little more obvious <em>why</em> the transducer's mandate of <em>a la carte</em> re-composition <em>demands</em> that <em>all</em> the new pulling apart <em>must be fully compatible</em> with <em>all</em> the old pulling apart.</p>
<h2 id="further-reading">Further reading</h2>
<p>Transducers are very deep conceptually, and literally. Since Clojure 1.7, they have come to underpin all of Clojure's heavy-lift capability.</p>
<p>I recommend drilling down this way.</p>
<p><em><strong>Thirty minute quickstart</strong></em></p>
<ul>
<li>Skim-read the official words introducing <a href="https://clojure.org/reference/transducers">Transducers</a>, and describing "<a href="https://clojure.org/guides/faq#transducers_vs_seqs">What are good use cases for transducers?</a>".</li>
<li>Watch <a href="https://twitter.com/timbaldridge">Tim Baldridge</a> lift the essence of transducers out from map/filter/reduce in 10 minutes: <a href="https://www.youtube.com/watch?v=WkHdqg_DBBs">Transducers - Episode 1 - Introduction to Transducers</a></li>
<li>Compare with <code>(clojure.repl/source map)</code> (and filter and reduce).</li>
</ul>
<p><em><strong>Half day binge watch</strong></em></p>
<ul>
<li>Watch Rich Hickey <a href="https://www.youtube.com/watch?v=6mTbuzafcII">introduce Transducers</a></li>
<li>Follow Tim Baldridge through <a href="https://tbaldridge.pivotshare.com/categories/transducers/2426/media">9 short video demos</a>, where he "draws the rest of the Owl" so to speak, but actually, with all the intermediate steps accounted for. IMHO, this is hands-down the best exploration of transducers out there <a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>.</li>
<li>Watch Rich Hickey dive <a href="https://www.youtube.com/watch?v=4KqUvG8HPYo">Inside Transducers</a>.</li>
</ul>
<p><em><strong>Grok some real-world Transduction</strong></em></p>
<ul>
<li><a href="https://github.com/bobby/kafka-streams-clojure">Kafkaesquely Streaming Transducery</a></li>
<li><a href="https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/">Grammar Transduction</a></li>
<li><a href="https://github.com/hyPiRion/haskell-transducers">Transducers Haskellized</a></li>
<li><a href="https://www.youtube.com/watch?v=1sC71eb9Ox0">Structure and Interpretation of Clojure Transducers</a> re:Clojure 2021 workshop, by Ben Sless</li>
</ul>
<p><em><strong>Exercise your brain</strong></em></p>
<ul>
<li>Write a FizzBuzz in Shell that can compute with any source/sink combination; in-line seq, mkfifo, files, sockets, URLs.</li>
<li>Next, replace <em>only</em> the Shell FizzBuzz function with the <code>basic-buzz</code> function we wrote (use babashka).</li>
<li>Finally, write an all-Clojure version around the <code>basic-buzz</code> function, <em>without</em> losing the the ability to transparently read/write from/to seq, mkfifo, file, socket, URL.</li>
</ul>
<pre class="shell"><code>man bash |
    tr -cs A-Za-z &#39;\n&#39; |
    tr A-Z a-z |
    sort | uniq -c | sort -rn |
    sed 10q
</code></pre>
<p><a href="https://www.evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/">;-)</a></p>
<h1 id="buzz"><span class="todo TODO">TODO</span> Buzz</h1>
<p>Ideas on deck, to put self on the hook…</p>
<ul>
<li>[ ] curried fizzbuzz (like Ring libraries),</li>
<li>[X] dispatch-based fizzbuzz (with multimethods),</li>
<li>[X] OOP fizzbuzz (with protocols),</li>
<li>[X] Nondestructive fizzbuzz (several!!!),</li>
<li>[ ] concurrent fizzbuzz (with agents, but the code in my head is probably totally wrong),</li>
<li>[X] parallel fizzbuzz, (just pmap, quite silly actually, but why not? It's legit!)</li>
<li>[X] transducing fizzbuzz, (should be able to transduce all the fizz-buzzes up to Peano FizzBuzz)</li>
<li>[ ] maaabe also re-do Rich's ants sim with FizzBuzz ants (4 species of, ah, ConcurrAnts — IdentiAnt, FizzAnt, BuzzAnt, FizzBuzzAnt).</li>
</ul>
<p>Outside of clojure.core, maaaaybe core.async fizzbuzz, but IDK, maybe that will be too high concept, and too contrived.</p>
<h1 id="acknowledgments">Acknowledgments</h1>
<p>Thanks to <a href="https://twitter.com/rdivyanshu"><span class="citation" data-cites="rdivyanshu">@rdivyanshu</span></a> for review and feedback and ideas.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Official and community-curated Clojure API docs <a href="https://clojure.org/api/api">https://clojure.org/api/api</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Official guide: <a href="https://clojure.org/guides/repl/introduction">Programming at the REPL</a>. The REPL is an <em>eager</em> beast. Lazy sequences want to never be fully realised, if possible. But, a REPL is typically designed to fully evaluate everything it gets. This is why we didn't feel the bite of mixing printing with lazy sequence generation. If we had this in our code somewhere, nothing would print, and any caller would get back just a useless collection of nils.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Laziness is a form of deferred computation. Clojure has "lazy sequences". <code>for</code> generates a lazy sequence. Several essay-length answers await your eager perusal. Rich Hickey's notes from back in the day: <a href="https://clojure.org/reference/lazy">Making Clojure Lazier</a>. Ramsharan G.J. muses <em>"<a href="https://www.youtube.com/watch?v=XCYTvZtTetI">Lazy Seqs - Why are they so lazy?</a>"</em> (<a href="https://speakerdeck.com/sharangj/lazy-sequences-why-are-they-so-lazy">slides</a>). Oitihjya Sen muses <a href="https://otee.dev/2022/01/17/lazy-clojure.html">Who Moved My Cheese: Laziness in Clojure</a>. Debashish Ghose has some thoughts on <a href="https://debasishg.blogspot.com/2010/05/laziness-in-clojure-some-thoughts.html">Laziness in Clojure</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Watch Rafal Dittwald refactor some Javascript in <a href="https://www.youtube.com/watch?v=vK1DazRK_a0">Solving Problems the Clojure Way</a>. Basically, we like to <em>prevent</em> side effecting code as much as humanely possible. When we can't, we do <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Functional Core Imperative Shell</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>The <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">full SICP textbook</a> is available free, online. The <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">video lecture series</a> from 1986. Further DuckDuck searches will yield various tours of SICP in Clojure. Still further into the deep end, there is now <a href="https://github.com/sicmutils">SICMUtils</a> in Clojure, built around the Structure and Interpretation of Classical Mechanics.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>To anyone writing Clojure tutorials, please for the love of lambda, <em><strong>do not</strong></em> use <code>println</code> to "show" people results. You may think you are being kind by using a familiar way to "show" results, but it is far better to rip the bandage off right from the get go. Double down on teaching good REPL habits and quality FP thinking instead.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Incidentally, the Classic implementation is also sensitive to the ordering of conditions, which is also a defect from a FP point of view, because there is no good reason to write an imperative control-flow-y interpretation of what could be a purely mathematical definition of FizzBuzz.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Well, maybe Rich can convince you otherwise: <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>I mean, don't be actively malicious, of course. However, such a <em>category</em> of error can happen. And if "they" git-blame-fire you, then I'd say celebrate. You inadvertently self-evicted from a place that will destroy your soul with bad systems and bad management.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>One fine day, one of our Clojure services at $FormerEmployer, started to run out of heap space after a fresh deployment. Our service graphs looked like this <code>_/|_/|_/|_</code>. The sawtooth of heap death. It wasn't super critical, and everybody was busy shipping features. So naturally we did some napkin math and rolled out a Jenkins job that triggered a rolling restart every six hours. Eventually, someone found the time to go debug the crashes. We had <em>memoized</em> a function that returned an anonymous function (a lambda or <em>thunk</em>), when we meant to memoize the return value from evaluating said lambda. Clojure creates a <em>new</em> object every time we ask it to make a lambda. So <a href="https://clojuredocs.org/clojure.core/memoize">memoize</a> saw new return values every time the original "thunkified" function was called, dutifully cached them all, and held onto them, thus preventing JVM garbage collector from cleaning them out. The story is relevant here because <em>thunking</em> (making functions return partially evaluated fuctions) is a form of delayed or "lazy" evaluation. Also because nobody was fired. Everyone learned a good lesson and had a good laugh. In fact, we continued to use the rolling restart job in at least one other case where the memory leak was very slow, the service was very fault tolerant, and the service owner was really pressed for time with other always-higher priorities in that hyper-growth phase of the company. Slow leak tolerance is very much justified when used carefully. In fact, the friend who owned that service recently told me the periodic restart method worked so well, that they almost forgot about it for several years until they did a whole data center migration, at which point the service crashed for the first time in years, because someone forgot to also switch on the restart job. More good laughs were had and the documentation and automation were improved. You may now like to read <a href="https://devblogs.microsoft.com/oldnewthing/20180228-00/?p=98125"><em>"An amusing story about a practical use of the null garbage collector"</em></a>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>"<a href="https://www.merriam-webster.com/dictionary/complect">Complect</a>"-ed, if you speak Clojurish. When a Thing is made of lots of Sub-Things that are braided together tightly, we say "This Thing is <em>complected</em>." in Clojurish. After we transform and reconstitute the Thing in terms of sub-things that are <em>no longer</em> braided together, we smile inwardly and say "This Thing is now <em>decomplected</em>". Clojurish is basically a postmodern revival of the Latin roots of American English.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Eric Normand on <em><a href="https://ericnormand.me/podcast/what-is-nil-punning">"What is Nil Punning?"</a></em>.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>For reference, <a href="https://github.com/adityaathalye/sicp/blob/master/ex2-06-church-numerals.scm">my attempt</a> at implementing <a href="https://en.wikipedia.org/wiki/Church_encoding">Church Numerals</a> in SICP.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>See the footnote for "Complect".<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>Arne Brasseur on <a href="https://www.lambdaisland.com/blog/2022-03-10-mechanism-vs-policy">Improve your code by separating mechanism from policy</a>. Don't you just love it when Lots Of Thoughts are rattling around in your brain, and someone drops a sweet one-liner that instantly crystallises it all for you? Thanks <a href="https://twitter.com/robstuttaford"><span class="citation" data-cites="RobStuttaford">@RobStuttaford</span></a> for bringing this back into my consciousness!<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>I see you and that <code>AbstractFactoryFactory</code> joke forming in your brain.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>See <a href="https://clojure.org/reference/multimethods">Multimethods and Hierarchies</a> page at the official site, and the <a href="https://clojuredocs.org/quickref#multifunctions">Multifunctions</a> section at ClojureDocs for examples. This stuff may break your brain for a bit, if you are very accustomed to Class-y OO programming. That's absolutely fine. It <em>is</em> fairly mind bending and takes some getting used to. Stay with it, play with concepts against the REPL. Translate or reduce as many patterns as you can to this kind of open-ended multiple dispatch.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>You can watch me flail about live-demoing a UI test automation DSL I designed using Clojure. <a href="https://www.youtube.com/watch?v=hwoLON80ZzA&amp;t=170s">Video</a>, <a href="https://github.com/adityaathalye/slideware/blob/master/designing_object_functional_system_IN-Clojure_2016.pdf">Slides</a>.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Aside: This is actually double-boxing, because in Java, numbers are already boxed by design. So this approach may carry some performance penalty depending on your context. For example, see this DZone &gt; Java Zone article: <a href="https://dzone.com/articles/whats-wrong-with-java-boxed-numbers">What's Wrong With Java Boxed Numbers?</a><a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>Yes I do: <a href="https://www.evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/">Shell ain't a bad place to FP</a> :)<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>Later, get all of <a href="https://tbaldridge.pivotshare.com/">Clojure Tutorials - With Tim Baldridge</a>. It is a joy to watch a master craftsman at work!<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
  <footer class="footer">
    <nav class="cluster">
      <span>&uarr; <a href="#blog-post" rel="bookmark">title</a></span>
      <span>&uarr; <a href="#site-header" rel="bookmark">menu</a></span>
    </nav>
  </footer>
</article>
        </main>
        <footer id="site-footer">
<hr>
<div class="box invert footer stack">
  <div class="cluster">
    <span>&#128231; : <a href="mailto:hello@evalapply.org">hello@evalapply.org</a></span>
    <a class="site-feed"
       href="https://evalapply.org/index.xml">
       Blog feed
    </a>
    <form class="cluster"
          action="https://buttondown.email/api/emails/embed-subscribe/evalapply"
          method="post" target="popupwindow"
          onsubmit="window.open('https://buttondown.email/evalapply','popupwindow')">
        <input type="email" name="email" id="bd-email">
      <span>
        <input type="submit" value="Get occasional newsletter">
        <em>(thanks, <a href="https://buttondown.email" target="_blank">Buttondown</a>!)</em>
      </span>
    </form>
  </div>
  <hr>
  <p>&copy; copyright 2022, <a href="https://evalapply.org" target="_blank">Aditya Athalye</a>.
    <span>Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
    Creative Commons Attribution-ShareAlike 4.0 International License
    </a>, the same one used by Wikipedia.</span>
<span><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
    <img alt="Creative Commons License" style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png">
    </a></span>
  </p>
  <hr>
  <p> Made with
      <a href="https://www.gnu.org/software/emacs/">GNU Emacs</a>,
      <a href="https://orgmode.org/">org-mode</a>, and
      <a href="https://github.com/adityaathalye/shite">shite</a>.
  </p>
  <p id="recurse-scout">
  <script async defer src="https://www.recurse-scout.com/loader.js?t=40533398b8c93bb4f3323a170e032e91"></script>
  </p>
</div>
</footer>
    </div>
  </body>
</html>
