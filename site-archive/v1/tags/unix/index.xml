<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unix on eval/apply</title><link>/tags/unix/</link><description>Recent content in unix on eval/apply</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 27 Apr 2022 21:43:19 +0530</lastBuildDate><atom:link href="/tags/unix/index.xml" rel="self" type="application/rss+xml"/><item><title>Shell ain't a bad place to FP: part 2/N: Functions as Unix Tools</title><link>/posts/shell-aint-a-bad-place-to-fp-part-2-functions-as-unix-tools/</link><pubDate>Wed, 27 Apr 2022 21:43:19 +0530</pubDate><guid>/posts/shell-aint-a-bad-place-to-fp-part-2-functions-as-unix-tools/</guid><description>&lt;p>Or, &lt;em>&lt;strong>the one in which we hand-craft nano Unix tools using Bash functions.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>As we saw in the &lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline">previous post&lt;/a>,
functions obey stdio and we can mix and match them with built-ins (grep, sed,
cat etc.) and other installed tools (like jq, pandoc, babashka etc.). We used
functions to name parts of Douglas McIlroy&amp;rsquo;s pipeline and mess around a bit.&lt;/p>
&lt;p>I tend to make libraries of pure functions that I can source in shell sessions
and use just like any other shell tool, complete with tab-completion. e.g.
&lt;a href="https://github.com/adityaathalye/bash-toolkit">bash-toolkit&lt;/a> and &lt;a href="https://github.com/adityaathalye/shite">shite&lt;/a>.&lt;/p>
&lt;p>Now we step back and try to build good intuitions about&lt;/p>
&lt;ul>
&lt;li>what functions are&lt;/li>
&lt;li>how to design good functions&lt;/li>
&lt;li>how to design programs with functions&lt;/li>
&lt;li>how to name them :)&lt;/li>
&lt;/ul></description><content>&lt;p>Or, &lt;em>&lt;strong>the one in which we hand-craft nano Unix tools using Bash functions.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>As we saw in the &lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline">previous post&lt;/a>,
functions obey stdio and we can mix and match them with built-ins (grep, sed,
cat etc.) and other installed tools (like jq, pandoc, babashka etc.). We used
functions to name parts of Douglas McIlroy&amp;rsquo;s pipeline and mess around a bit.&lt;/p>
&lt;p>I tend to make libraries of pure functions that I can source in shell sessions
and use just like any other shell tool, complete with tab-completion. e.g.
&lt;a href="https://github.com/adityaathalye/bash-toolkit">bash-toolkit&lt;/a> and &lt;a href="https://github.com/adityaathalye/shite">shite&lt;/a>.&lt;/p>
&lt;p>Now we step back and try to build good intuitions about&lt;/p>
&lt;ul>
&lt;li>what functions are&lt;/li>
&lt;li>how to design good functions&lt;/li>
&lt;li>how to design programs with functions&lt;/li>
&lt;li>how to name them :)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;a href="#previously-in-this-series-dot-dot-dot">Previously in this series&amp;hellip;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#what-bash-functions-are">What Bash functions are&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#bash-functions-are-compound-commands">Bash functions are compound commands&lt;/a>&lt;/li>
&lt;li>&lt;a href="#function-definitions-live-in-a-global-namespace">Function definitions live in a global namespace&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#how-to-design-good-functions">How to design good functions&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#wrap-domain-concepts-in-single-purpose-functions">Wrap domain concepts in single-purpose functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#use-parameter-substitutions-and-local-scope-variables">Use parameter substitutions and local scope variables&lt;/a>&lt;/li>
&lt;li>&lt;a href="#partial-application-of-functions">Partial application of functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dependency-injection-with-functions">Dependency injection with functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#keeping-functions-pure">Keeping Functions pure&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#program-design-with-functions">Program design with functions&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#writing-pipeline-friendly-functions">Writing Pipeline-friendly Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#separating-return-values-and-non-values">Separating return values and non-values&lt;/a>&lt;/li>
&lt;li>&lt;a href="#functions-to-delay-evaluation">Functions to delay evaluation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#functional-core-imperative-shell">Functional core, imperative shell&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#naming-conventions">Naming conventions&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="previously-in-this-series-dot-dot-dot">Previously in this series&amp;hellip;&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline">Part 1/N&lt;/a>:
Exploring McIlroy&amp;rsquo;s pipeline to motivate the series. And an unexpected
masterclass from the Master himself (see appendix)!&lt;/li>
&lt;li>&lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-0-intro/">Part 0/N&lt;/a>:
intro, caveats, preamble&lt;/li>
&lt;/ul>
&lt;h2 id="what-bash-functions-are">What Bash functions are&lt;/h2>
&lt;p>Last time, we wrote functions like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">flatten_paragraphs&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The syntax may look familiar, but their behaviour and semantics differ in
many ways from functions in the more modern languages like Python or JS etc.&lt;/p>
&lt;h3 id="bash-functions-are-compound-commands">Bash functions are compound commands&lt;/h3>
&lt;p>&lt;code>man bash&lt;/code> describes functions as follows (online manpage: &lt;a href="https://www.gnu.org/software/bash/manual/html%5Fnode/Shell-Functions.html">shell functions&lt;/a>).&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Shell Function Definitions&lt;/strong>&lt;/p>
&lt;p>A shell function is an object that is called like a simple command and
executes a compound command with a new set of positional parameters.
Shell functions are declared as follows:&lt;/p>
&lt;p>&lt;code>name () compound-command [redirection]&lt;/code>&lt;/p>
&lt;p>&amp;hellip; and more stuff &amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>We will do names last, because names are hard :) Let&amp;rsquo;s start with the
&amp;ldquo;compound command&amp;rdquo; part.&lt;/p>
&lt;p>There are several ways to write &lt;em>compound commands&lt;/em>, each serving a different
purpose. To define functions, we only need the &lt;code>{ list; }&lt;/code> form. So we will
ignore the others. Some context from the Bash manpage.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Compound Commands&lt;/strong>&lt;/p>
&lt;p>A compound command is one of the following. In most cases a list in a
command&amp;rsquo;s description may be separated from the rest of the command by
one or more newlines, and may be followed by a newline in place of a semicolon.&lt;/p>
&lt;p>&lt;code>(list)&lt;/code>
list is executed in a subshell environment &amp;hellip;&lt;/p>
&lt;p>&lt;code>{ list; }&lt;/code>
list is simply executed in the current shell environment. list
must be terminated with a newline or semicolon. This is known as
a group command. The return status is the exit status of list.
Note that unlike the metacharacters ( and ), { and } are reserved
words and must occur where a reserved word is permitted to be
recognized. Since they do not cause a word break, they must be
separated from list by whitespace or another shell metacharacter.&lt;/p>
&lt;p>&lt;code>((expression))&lt;/code>
Arithmetic expressions &amp;hellip;&lt;/p>
&lt;p>&lt;code>[[ expression ]]&lt;/code>
Compound conditional expression &amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>The Bash manual page can feel a little obtuse at times. Hopefully the examples
and discussion in this post will serve as useful illustrations.&lt;/p>
&lt;h3 id="function-definitions-live-in-a-global-namespace">Function definitions live in a global namespace&lt;/h3>
&lt;p>This means function definitions are isolated, and don&amp;rsquo;t override any alias,
builtin, variable, or reserved keyword of the same name.&lt;/p>
&lt;p>To see what that means, let&amp;rsquo;s bind the same name to different things.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ sed&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span> echo lol; &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#75715e"># will the function override the sed built-in?&lt;/span>
$ sed&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;phew!&amp;#34;&lt;/span> &lt;span style="color:#75715e"># will the variable override the function we defined?&lt;/span>
$ alias sed&lt;span style="color:#f92672">=&lt;/span>cat &lt;span style="color:#75715e"># will the alias override everything?&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can query all objects that the name &lt;code>sed&lt;/code> is bound to. (Note: the variable
meaning won&amp;rsquo;t show up in this listing.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ type -a sed
sed is aliased to &lt;span style="color:#e6db74">&amp;#39;cat&amp;#39;&lt;/span>
sed is a &lt;span style="color:#66d9ef">function&lt;/span>
sed &lt;span style="color:#f92672">()&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
echo lol
&lt;span style="color:#f92672">}&lt;/span>
sed is /bin/sed
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And we can invoke or evaluate each meaning of the word &lt;code>sed&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ man bash | sed &lt;span style="color:#75715e"># Oops. Boy, are we in trouble now.&lt;/span>
&lt;span style="color:#75715e"># Bash interprets the unquoted word as an alias, which is &amp;#39;cat&amp;#39;.&lt;/span>
$ man bash | command sed 1q &lt;span style="color:#75715e"># execute as a command (not function, or alias)&lt;/span>
BASH&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> General Commands Manual BASH&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
$ &lt;span style="color:#e6db74">&amp;#39;sed&amp;#39;&lt;/span> &lt;span style="color:#75715e"># quoting prevents interpretation as alias. Function meaning gets used.&lt;/span>
lol
$ echo foo | &lt;span style="color:#e6db74">&amp;#39;sed&amp;#39;&lt;/span> &lt;span style="color:#75715e"># works fine in pipes too&lt;/span>
lol
$ echo $sed &lt;span style="color:#75715e"># the variable remains intact too&lt;/span>
phew!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This namespacing is certainly merciful, but it is not quite enough. As you
may have guessed, it can get very confusing if we reuse names willy-nilly.
If there was one thing I could improve about Bash, it would be adding &amp;ldquo;real&amp;rdquo;
namespaces. That would help write modular code. Alas, that ship sailed long ago.&lt;/p>
&lt;p>Anyway, I drop Bash after the code starts getting too involved; beyond about
1,000 LoC (of clean FP-style Bash). In large scripts, the sharp corners of Ye
Olde Shell start poking holes and forcing bugs (quoting, expansion, trap/error
handling etc.).&lt;/p>
&lt;p>That said (or um, sed), under 1K LoC clean FP-style Bash can do a crazy amount
of work sufficiently fast &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. That sweet spot is what this series
is all about. Like &lt;a href="https://github.com/adityaathalye/shite">shite&lt;/a> and &lt;a href="https://github.com/adityaathalye/oxo">oxo&lt;/a>.&lt;/p>
&lt;h2 id="how-to-design-good-functions">How to design good functions&lt;/h2>
&lt;p>Bash functions provide certain highly functional features like obeying stdio,
thus being streaming-friendly units of program design. Several other creature
comforts of functional style are not automatic. &lt;em>However&lt;/em> we can get plenty
functional with &lt;em>some&lt;/em> care and manual effort.&lt;/p>
&lt;p>Here are things I do to keep my functions, well, functional.&lt;/p>
&lt;h3 id="wrap-domain-concepts-in-single-purpose-functions">Wrap domain concepts in single-purpose functions&lt;/h3>
&lt;p>Previously, we wrapped invocations of Unix tools and pipelines in functions,
gave them domain-specific names, to achieve domain-specific compositional power.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">sort_dictionary&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sort -b -d -k2
&lt;span style="color:#f92672">}&lt;/span>
sort_rhyme&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
rev | sort -b -d | rev
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Small functions are absolutely fine! In fact, we prefer our functions be small,
single-purpose, and as general as possible, just like any other Unix tool.&lt;/p>
&lt;h3 id="use-parameter-substitutions-and-local-scope-variables">Use parameter substitutions and local scope variables&lt;/h3>
&lt;p>Functions only accept positional parameters, like regular shell scripts. And
like regular scripts, we can send input for evaluation as well as to control
behaviour of the function, as well will see later in this post.&lt;/p>
&lt;p>Unfortunately, positional-only params make optionality hard. The following
techniques help mitigate this limitation. Compare them with the example below.&lt;/p>
&lt;ul>
&lt;li>I tend to keep my functions small and avoid API design that requires more
than 3 parameters. This is just a nonscientific thumb rule.&lt;/li>
&lt;li>Next, I use Bash parameter substitution to provide sane fallbacks, and/or
enforce API contracts (fail and die if param not provided).&lt;/li>
&lt;li>I always assign positional params to local variables inside the function
body, which is a bit verbose, but improves readability and traceability.
And it makes any parameter substitution explicit.&lt;/li>
&lt;li>I also declare all named params as &lt;code>local&lt;/code>, which ensures variable scope
and mutation is local to the function.&lt;/li>
&lt;/ul>
&lt;p>Most of my parameter-accepting functions are designed with just one optional
parameter. Here is a motivating example from my little &lt;a href="https://github.com/adityaathalye/bash-toolkit">bash-toolkit&lt;/a> library.
The ones copied here help with ad-hoc log analysis tasks.&lt;/p>
&lt;p>Accept optional parameter, with a sane default.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">drop_first_n&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local lines&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>0&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local offset&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span> lines &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">))&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
tail -n +&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>offset&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
drop_last_n&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local lines&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>0&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
head -n -&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>lines&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Enforce all parameters, as these functions are meaningless without them.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">drop_header_footer&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local header_lines&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1:?&lt;span style="color:#e6db74">&amp;#39;FAIL. Header line count required, 1-indexed.&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local footer_lines&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2:?&lt;span style="color:#e6db74">&amp;#39;FAIL. Footer line count required, 1-indexed.&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
drop_first_n &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>header_lines&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> |
drop_last_n &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>footer_lines&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
window_from_to_lines&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local from_line&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1:?&lt;span style="color:#e6db74">&amp;#39;FAIL. \&amp;#34;FROM\&amp;#34; line number required, 1-indexed.&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local to_line&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2:?&lt;span style="color:#e6db74">&amp;#39;FAIL. \&amp;#34;TO\&amp;#34; line number required, 1-indexed.&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
drop_first_n &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>from_line&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> |
head -n &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>to_line&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice how the latter two functions reuse the earlier functions to create
completely different log processing tools, yet retain flexibility to deal with
arbitrary parts of log files, as well as compose together any way we please
(not all of which will be sensible, but that&amp;rsquo;s besides the point :).&lt;/p>
&lt;p>There are many ways to do &lt;a href="https://wiki.bash-hackers.org/scripting/posparams">parameter handling&lt;/a>; a whole topic of its own.
Play around to get a sense for it, but keep your actual usage simple.&lt;/p>
&lt;h3 id="partial-application-of-functions">Partial application of functions&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Partial%5Fapplication">Partial application&lt;/a> is not automatic in Bash,
but that does not mean we can&amp;rsquo;t do it.&lt;/p>
&lt;p>In the example below, a utility function &lt;code>__with_git_dir&lt;/code> knows something
about a git directory, but nothing about a git subcommand that we wish to run.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">__with_git_dir&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
shift
git --git-dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/.git&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
git_fetch&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
__with_git_dir &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> fetch -q
&lt;span style="color:#f92672">}&lt;/span>
git_status&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
__with_git_dir &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> status
&lt;span style="color:#f92672">}&lt;/span>
git_branch_current&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
__with_git_dir &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> rev-parse --abbrev-ref&lt;span style="color:#f92672">=&lt;/span>strict HEAD
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These functions &lt;a href="https://github.com/adityaathalye/bash-toolkit/blob/7cbac8bd6a7970481f6f62e5a2a604afcaf804ea/bulk-git-ops.sh#L99">belong to some git utilities&lt;/a> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> that
help me conveniently run git commands against any repo on my file system,
without cd-ing to the repo.&lt;/p>
&lt;p>See? Functions can be dead-simple yet super useful. If you accumulate wee
functions for your git needs, you get executable documentation. You can &lt;code>source&lt;/code>
them in your Bash terminal on any computer and be on your way. Likewise, any
other command-line-y need of yours.&lt;/p>
&lt;h3 id="dependency-injection-with-functions">Dependency injection with functions&lt;/h3>
&lt;p>The previous section brought us close to dependency injection. We passed in
git subcommands as argument to the &lt;code>__with_git_dir&lt;/code> utility. &lt;em>&lt;strong>We can do the
same with our own functions.&lt;/strong>&lt;/em> This is a form of &amp;ldquo;higher order&amp;rdquo; Functional
Programming; viz. making functions that accept functions as arguments.&lt;/p>
&lt;p>For example, &lt;a href="https://github.com/adityaathalye/bash-toolkit/blob/7cbac8bd6a7970481f6f62e5a2a604afcaf804ea/bulk-git-ops.sh">see the same git utilities file&lt;/a> for usages such as these:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Use the &lt;code>xgit&lt;/code> utility fn to apply simple git commands to the given repos.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">ls_git_projects ~/src/bitbucket | xgit fetch &lt;span style="color:#75715e"># bitbucket-hosted repos&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Use &lt;code>proc_repos&lt;/code> to apply custom functions to the given repos.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">ls_git_projects ~/src/bitbucket |
proc_repos git_fetch &lt;span style="color:#75715e"># all repos&lt;/span>
ls_git_projects ~/src/bitbucket |
take_stale |
proc_repos git_fetch &lt;span style="color:#75715e"># only stale repos&lt;/span>
ls_git_projects ~/src/bitbucket |
take_active |
proc_repos git_fetch &lt;span style="color:#75715e"># only active repos&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>What&amp;rsquo;s the current branch?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">ls_git_projects ~/src/bitbucket |
proc_repos git_branch_current
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;ve also used this design technique in &lt;a href="https://github.com/adityaathalye/shite">shite&lt;/a>
(the little static site generator from shell :).
This is baaasically what its &lt;a href="https://github.com/adityaathalye/shite/blob/f8d2d22316a8c2fc04c92c1390abb77c69377f6f/shite%5Futils.sh#L237">&amp;ldquo;main&amp;rdquo; function&lt;/a> does.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># Build page and tee it into the public directory, namespaced by the slug&lt;/span>
cat &lt;span style="color:#e6db74">${&lt;/span>body_content_file&lt;span style="color:#e6db74">}&lt;/span> |
&lt;span style="color:#e6db74">${&lt;/span>content_proc_fn&lt;span style="color:#e6db74">}&lt;/span> |
&lt;span style="color:#75715e"># We have only one page builder today, but&lt;/span>
&lt;span style="color:#75715e"># we could have a variable number tomorrow.&lt;/span>
shite_build_page |
&lt;span style="color:#e6db74">${&lt;/span>html_formatter_fn&lt;span style="color:#e6db74">}&lt;/span> |
tee &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>shite_global_data[publish_dir]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>html_output_file_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>All the &lt;code>_fn&lt;/code>-suffixed variables are locals in the &amp;ldquo;main&amp;rdquo; fn, that are
assigned to function names we pass from the outside. Also notice the use of
sane fallbacks for the positional params in this case.&lt;/p>
&lt;h3 id="keeping-functions-pure">Keeping Functions pure&lt;/h3>
&lt;p>The &lt;code>return&lt;/code> statement in Bash returns exit codes, not values. So we have to
pause a bit to figure out how to &amp;ldquo;return&amp;rdquo; values. Well, we have to rely on
stdio, and the fact that the Unix tools philosophy encourages us to emit data
in the same format as we receive it.&lt;/p>
&lt;p>The &lt;code>identity&lt;/code> function is the simplest example. By definition, it returns
its input unchanged. That&amp;rsquo;s just &lt;code>cat&lt;/code>! Thus we can write this streaming
&lt;em>identity&lt;/em> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">identity&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
cat -
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This definition of &lt;em>identity&lt;/em> is surprisingly useful, as we will see below.&lt;/p>
&lt;p>Note that I strongly favour pipeline-friendly domain modeling and functional
programming, to profit from the naturally streaming nature of Unix.&lt;/p>
&lt;p>Under such architecture, &lt;em>map&lt;/em>, &lt;em>filter&lt;/em>, and &lt;em>reduce&lt;/em> are automatic, and I
only need to write a pure &amp;ldquo;step&amp;rdquo; or single-item processing function.&lt;/p>
&lt;p>My &amp;ldquo;step&amp;rdquo; functions are simply transforms of input text (or data structure)
to output text (or data structure). This can be anything; in case of plain
text lines I do line transforms with &lt;code>sed&lt;/code> or &lt;code>printf&lt;/code>, or line selects
with &lt;code>grep&lt;/code>, or line-munging with &lt;code>tr&lt;/code> etc. I do the equivalent with &lt;code>jq&lt;/code>
for JSON-formatted lines. &lt;a href="http://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/">The previous post&lt;/a> featured such &amp;ldquo;step&amp;rdquo; functions
for &lt;em>map&lt;/em> (&lt;code>tokenise_lowercase&lt;/code>, &lt;code>bigram&lt;/code>), &lt;em>filter&lt;/em> (&lt;code>drop_stopwords&lt;/code>), and
&lt;em>reduce&lt;/em> (&lt;code>frequencies&lt;/code>, &lt;code>sort_dictionary&lt;/code>).&lt;/p>
&lt;p>&lt;em>shite&lt;/em> has a &lt;a href="https://github.com/adityaathalye/shite/blob/f8d2d22316a8c2fc04c92c1390abb77c69377f6f/shite%5Futils.sh#L89">more interesting example&lt;/a>.&lt;/p>
&lt;p>Suppose we want to make a blog site. For each blog post, only the content
changes. The surrounding HTML wrapper remains constant (head, body, header,
footer etc.). If we tease apart wrapper HTML construction and body HTML
construction, then we can write a &amp;ldquo;page builder&amp;rdquo; function like this. Note
the &lt;code>cat -&lt;/code> in the middle. Our identity function appears!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">shite_build_page&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
cat &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span style="color:#e6db74">&amp;lt;!DOCTYPE html&amp;gt;
&lt;/span>&lt;span style="color:#e6db74">&amp;lt;html&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;head&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;!-- Some basic hygiene meta-data --&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;title&amp;gt;My Blog&amp;lt;/title&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;css/style.css&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;/head&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;body&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;header id=&amp;#34;site-header&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;h1&amp;gt;My Blog&amp;lt;/h1&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;hr&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;/header&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;main&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> $(cat -)
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;/main&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;footer&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;hr&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;p&amp;gt;All content is MIT licensed, except where specified otherwise.&amp;lt;/p&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;/footer&amp;gt;
&lt;/span>&lt;span style="color:#e6db74"> &amp;lt;/body&amp;gt;
&lt;/span>&lt;span style="color:#e6db74">&amp;lt;/html&amp;gt;
&lt;/span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observe that &lt;code>$(cat -)&lt;/code> blindly injects content in the &lt;code>&amp;lt;main&amp;gt;&amp;lt;/main&amp;gt;&lt;/code> block,
received via stdin of the &lt;em>function&lt;/em> &lt;code>shite_build_page&lt;/code>. Thus, for the same
input it will always produce the same output, making it a pure function.
This choice also makes the caller responsible for passing it HTML, because
the output is HTML.&lt;/p>
&lt;p>Further, by the single responsibility principle, our function&amp;rsquo;s job is simply
to punch HTML content into an HTML wrapper and return the composite. So it is
vital that this function &lt;em>not know or care&lt;/em> how the HTML it receives is made.&lt;/p>
&lt;p>And here&amp;rsquo;s the cherry&amp;hellip; By making this design choice, we have in fact made
a step function that we can &lt;em>map&lt;/em> over many blog posts.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">gen_html_posts_from_md&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> read blog_post_md_file
&lt;span style="color:#66d9ef">do&lt;/span> local html_file_name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>basename -s.md &lt;span style="color:#e6db74">${&lt;/span>blog_post_md_file&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">.html&amp;#34;&lt;/span>
pandoc -f markdown -t html &lt;span style="color:#e6db74">${&lt;/span>html_file_name&lt;span style="color:#e6db74">}&lt;/span> |
shite_build_page &amp;gt; ./public/posts/&lt;span style="color:#e6db74">${&lt;/span>html_file_name&lt;span style="color:#e6db74">}&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, if our blog posts are &lt;code>markdown&lt;/code> files in some folder (let&amp;rsquo;s say under
a &lt;code>content&lt;/code> directory). We can do this.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">find ./content/posts/ -type f -name *.md |
gen_html_posts_from_md
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A reader may complain that our HTML posts generator function is too specific
to the markdown format, and knows too much about how to transform markdown
to HTML, as well as where to put it. Its job ought to be just to describe
the transform process.&lt;/p>
&lt;p>The reader would be right, and may like to solve the problem at home &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> :)&lt;/p>
&lt;h2 id="program-design-with-functions">Program design with functions&lt;/h2>
&lt;p>Now, how do we apply functional programming principles to the next level up,
viz. to design our programs?&lt;/p>
&lt;p>If you&amp;rsquo;ve seen shell scripts in the wild, you&amp;rsquo;d have observed they are often
written as sequences of statements and imperative control flow that evaluates
top to bottom. I think that practice is a bit tragic, because it produces
needlessly complex code, because people reach for flags and global variables
and traps and suchlike.&lt;/p>
&lt;p>Functions obviate a lot of that icky stuff. We still need the ick, but we can
constrain it to very specific tightly controlled bits of our program, and only
when the ick makes absolute sense.&lt;/p>
&lt;p>I will also say that if we can make programs that are themselves functional
compositions, then we can chain entire programs together into still larger
scale functional structures. Further, since stdio includes named pipes, and
sockets, we can compose multi-process as well as multi-machine pipelines,
with a great economy of code. And this is &lt;em>not&lt;/em> insane at all. Seriously.&lt;/p>
&lt;p>But I&amp;rsquo;m getting ahead of myself. Here is how I try to keep my programs functional.&lt;/p>
&lt;h3 id="writing-pipeline-friendly-functions">Writing Pipeline-friendly Functions&lt;/h3>
&lt;p>Frequently, an imperative algorithm can also be expressed in data-flow terms.
That is, instead of if-else-y code, think in terms of map/filter/reduce.&lt;/p>
&lt;p>Once again, recalling the git utility functions referenced above. Suppose you
had to return a list of &amp;ldquo;stale&amp;rdquo; repositories from a given directory, you may
be tempted to write something like this. (Here &amp;ldquo;stale&amp;rdquo; means &amp;ldquo;not worked on
for the last N hours&amp;rdquo;).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">get_stale_repos&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repos_root_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local stale_hrs&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2&lt;span style="color:#66d9ef">:-&lt;/span>12&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local hrs_ago&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date +%s&lt;span style="color:#66d9ef">)&lt;/span>
&lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>stat -c %Y &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/.git&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">3600&lt;/span> &lt;span style="color:#66d9ef">))&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> repo_dir in &lt;span style="color:#66d9ef">$(&lt;/span>ls &lt;span style="color:#e6db74">${&lt;/span>repos_root_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> $hrs_ago -le $stale_hrs &lt;span style="color:#f92672">]]&lt;/span>
&lt;span style="color:#66d9ef">then&lt;/span> printf &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;active: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span> printf &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;stale: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However this kind of implementation combines (&amp;ldquo;complects&amp;rdquo;) many different things.&lt;/p>
&lt;p>Given the fact that functions respect &lt;code>stdio&lt;/code>, we can pull apart our imperative
attempt. The insight is to combine &lt;code>while&lt;/code> and &lt;code>read&lt;/code> as follows. I use this
idiom a lot because it helps me drastically simplify my code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">__is_repo_active&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local stale_hrs&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2&lt;span style="color:#66d9ef">:-&lt;/span>12&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local hrs_ago&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date +%s&lt;span style="color:#66d9ef">)&lt;/span>
&lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>stat -c %Y &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/.git&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">3600&lt;/span> &lt;span style="color:#66d9ef">))&lt;/span>
&lt;span style="color:#f92672">[[&lt;/span> $hrs_ago -le $stale_hrs &lt;span style="color:#f92672">]]&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
take_stale&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir
&lt;span style="color:#66d9ef">while&lt;/span> read repo_dir
&lt;span style="color:#66d9ef">do&lt;/span> __is_repo_active &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> printf &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can do this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">ls ~/src/github/adityaathalye |
take_stale
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And we get bonus reuse, because we may also want to do the inverse.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">take_active&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local repo_dir
&lt;span style="color:#66d9ef">while&lt;/span> read repo_dir
&lt;span style="color:#66d9ef">do&lt;/span> __is_repo_active &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> printf &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With a little bit more thinking, we can pull apart this logic even further,
usefully. Hint: these functions have a &lt;code>filter&lt;/code> embedded inside them.&lt;/p>
&lt;p>As another fun example, one @rsms &lt;a href="https://twitter.com/rsms/status/1508900257324666882">tweeted this&lt;/a> recently:&lt;/p>
&lt;blockquote>
&lt;p>Was curious about source code-line length so wrote a horribly hacky bash
script that draws a histogram. &lt;a href="https://gist.github.com/rsms/36bda3b5c8ab83d951e45ed788a184f4">https://gist.github.com/rsms/36bda3b5c8ab83d951e45ed788a184f4&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>I saw the script and my habitual thought kicked in, &amp;ldquo;Well, why can&amp;rsquo;t that be
a pipeline?&amp;rdquo;. A short while later, this emerged.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># get some lines of text&lt;/span>
man bash |
&lt;span style="color:#75715e"># remove blank lines (extensible to any non-code lines)&lt;/span>
grep -v &lt;span style="color:#e6db74">&amp;#39;^$&amp;#39;&lt;/span> |
&lt;span style="color:#75715e"># count chars for each line&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> read line; &lt;span style="color:#66d9ef">do&lt;/span> echo &lt;span style="color:#e6db74">${&lt;/span>line&lt;span style="color:#e6db74">}&lt;/span> | wc -c - | cut -d&lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> -f1; &lt;span style="color:#66d9ef">done&lt;/span> |
&lt;span style="color:#75715e"># calculate the frequency distribution&lt;/span>
sort -nr | uniq -c |
&lt;span style="color:#75715e"># add a histogram graph to the frequency distribution&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> read lines cols;
&lt;span style="color:#66d9ef">do&lt;/span> printf &lt;span style="color:#e6db74">&amp;#34;%s\t%s\t%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>lines&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>cols&lt;span style="color:#e6db74">}&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>printf &lt;span style="color:#e6db74">&amp;#34;%0.s|&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>cols&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>;
&lt;span style="color:#66d9ef">done&lt;/span> |
&lt;span style="color:#75715e"># add labels to the histogram&lt;/span>
cat &amp;lt;&lt;span style="color:#f92672">(&lt;/span>printf &lt;span style="color:#e6db74">&amp;#34;%s\t%s\t%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;LN&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;COL&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HIST(|=8COL)&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> -
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note the similarities to McIlroy&amp;rsquo;s pipeline from the last post. Also, like
that program, mine too fits in a tweet and I wasn&amp;rsquo;t even trying.&lt;/p>
&lt;h3 id="separating-return-values-and-non-values">Separating return values and non-values&lt;/h3>
&lt;p>&amp;ldquo;Don&amp;rsquo;t be chatty&amp;rdquo; is an important design principle. This means don&amp;rsquo;t pollute
your stdout values with non-values. Sometimes though, we want to emit process
information (like logs) &lt;em>along&lt;/em> with emitting process output. For example,
a structured process log becomes handy when we want to design idempotent jobs.&lt;/p>
&lt;p>Going back to my &lt;a href="https://github.com/adityaathalye/bash-toolkit/blob/7cbac8bd6a7970481f6f62e5a2a604afcaf804ea/bulk-git-ops.sh#L49">bulk-git-ops example&lt;/a>,
suppose I want to process a whole bunch of git repos. This may fail any time
if my network flakes, or laptop battery dies, or some weird condition occurs.
Sh*t happens when processes run for a long time &lt;em>and&lt;/em> need networks. So I
usually want to log each repo as it is being processed.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">identity&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
printf &lt;span style="color:#e6db74">&amp;#34;%s\n&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
proc_repos&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># Apply any given operation on the given repos. Use in a pipeline.&lt;/span>
&lt;span style="color:#75715e"># Presumably, the supplied function emits values expected by stdin&lt;/span>
&lt;span style="color:#75715e"># of the downstream function.&lt;/span>
local func&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>identity&lt;span style="color:#e6db74">}&lt;/span>
local repo_dir
&lt;span style="color:#66d9ef">while&lt;/span> read repo_dir
&lt;span style="color:#66d9ef">do&lt;/span> $func &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
log_info &lt;span style="color:#e6db74">&amp;#34;Applied &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>func&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> to &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>repo_dir&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This way a downstream consumer can rely on always receiving a legal value at
stdin, and &lt;em>optionally&lt;/em> access non-values (like logs), if it wants to, via
stderr &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>I casually name-dropped &lt;em>idempotence&lt;/em>. It needs its own blog post. Maybe the
next one!&lt;/p>
&lt;h3 id="functions-to-delay-evaluation">Functions to delay evaluation&lt;/h3>
&lt;p>I like to write my code in groups and sequences that help a reader acquire
context easily, and I call it in sequences that make sense from a process
point of view. Functions help me do this, because they group statements in
the scope of the script, &lt;em>without&lt;/em> causing the interpreter to evaluate them.&lt;/p>
&lt;p>For example, scripts I wrote:&lt;/p>
&lt;ul>
&lt;li>to &lt;a href="https://gitlab.com/nilenso/cats/-/blob/c26bcd7e6618843690070b8bf38cf7adb553a0d2/bin/cicd-deployment.sh#L122">perform build/deploy steps&lt;/a> for a study project&lt;/li>
&lt;li>to help me &lt;a href="https://github.com/adityaathalye/bash-toolkit/blob/7cbac8bd6a7970481f6f62e5a2a604afcaf804ea/machine-setup.sh#L274">set up my machine&lt;/a> (or at least remember what I have use for :)&lt;/li>
&lt;/ul>
&lt;h3 id="functional-core-imperative-shell">Functional core, imperative shell&lt;/h3>
&lt;p>Pun intended. This is &lt;a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">a very useful design technique&lt;/a>.&lt;/p>
&lt;p>We lift out as much work as possible into lots of small, pure, single purpose
functions, and compose these separately to do composite work and/or to cause
effects (perform I/O, set/reset globals, mutate in-process state etc.).&lt;/p>
&lt;p>You may observe it applied in all my code:&lt;/p>
&lt;ul>
&lt;li>My &lt;a href="https://github.com/adityaathalye/bash-toolkit/blob/7cbac8bd6a7970481f6f62e5a2a604afcaf804ea/usage-trap.sh#L109">usage-trap file&lt;/a>
is a template for how I tend to go about that for single-file scripts.&lt;/li>
&lt;li>The whole game design of &lt;a href="https://github.com/adityaathalye/oxo">oxo&lt;/a>:
&lt;ul>
&lt;li>The &lt;code>oxo_logic.sh&lt;/code> file is the &amp;ldquo;functional core&amp;rdquo;.&lt;/li>
&lt;li>The &lt;code>oxo&lt;/code> file is the &amp;ldquo;imperative shell&amp;rdquo; (and is the game&amp;rsquo;s entry point).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/adityaathalye/shite">shite&lt;/a> is being developed exactly this way.&lt;/li>
&lt;/ul>
&lt;p>This technique helps me develop scripts incrementally, in terms of highly
reusable, testable, composable functional &amp;ldquo;lego blocks&amp;rdquo;.&lt;/p>
&lt;h2 id="naming-conventions">Naming conventions&lt;/h2>
&lt;p>Now the really hard part&amp;hellip;&lt;/p>
&lt;p>I write all my function names as follows, because it is the most portable
syntax. Bash accepts several ways to define functions, but POSIX sh strictly
expects this syntax, and I prefer to maintain as much compatibility as I can.
Also I find it is the neatest of the alternatives.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">namespace_func_name&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
statement &lt;span style="color:#ae81ff">1&lt;/span>
statement &lt;span style="color:#ae81ff">2&lt;/span>
statement &lt;span style="color:#ae81ff">3&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sometimes I write short one-liners as follows. The semicolon is essential
for one-liners. So is the space between the braces and the statement.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">namespace_func_name&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span> statement ; &lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There is no such thing as a &amp;ldquo;private&amp;rdquo; or locally-scoped function, so I resort
to marking these &amp;ldquo;private&amp;rdquo; by convention with a &lt;code>__&lt;/code> (double underscore) prefix.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">__namespace_private_func_name&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
statement1
statement2
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The following syntax is legal Bash, but I do not use it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#66d9ef">function&lt;/span> namespace_func_name &lt;span style="color:#f92672">{&lt;/span>
statement1
statement2
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> namespace_func_name&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
statement1
statement2
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e"># OR one-liner variants&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> namespace_func_name &lt;span style="color:#f92672">{&lt;/span> statement ; &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> namespace_func_name&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span> statement ; &lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bash accepts &lt;code>.&lt;/code> and &lt;code>-&lt;/code> in function names, but that is also a no-no for me.
A linter like Shellcheck will complain in strict mode.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">namespace.funcname&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
statement &lt;span style="color:#ae81ff">1&lt;/span>
statement &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
namespace-funcname&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
statement &lt;span style="color:#ae81ff">1&lt;/span>
statement &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok, we covered a lot of ground, so I&amp;rsquo;ll stop for now. There are more aspects
of FP in bash (idempotence, declarative programming etc.), for future posts.
But even this much will elevate your shell-fu, and let you write nontrivial
scripts incrementally, safely, and maintainably.&lt;/p>
&lt;p>Happy Bash-ing!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>And if you use awk, I hear that it is known to outperform hand optimized C for a variety of data processing problems. Apparently genomics people awk a lot.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>You may particularly enjoy those if you sometimes (or often) have to do bulk maintenance on many repos. Fetch and update them, or at least identify stale repos before deciding what to do etc.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>Hint: Partial application and/or dependency injection may be appropriate.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>Monads. There, I said it.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content></item><item><title>Shell ain't a bad place to FP: part 1/N: McIlroy's Pipeline</title><link>/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/</link><pubDate>Fri, 11 Mar 2022 00:08:52 +0530</pubDate><guid>/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/</guid><description>&lt;p>Or, &lt;em>&lt;strong>the one in which we &amp;ldquo;take apart&amp;rdquo; Douglas McIlroy&amp;rsquo;s pipeline from 1986.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Doing so teaches an object lesson about the essence of modular, composable,
functional architecture. And things start to really heat up when it dawns on
us, how a good set of standard parts can be used to express totally different
ideas &lt;em>just by composing them in different ways&lt;/em>.&lt;/p>
&lt;p>(Edit 2022-03-10: speaking of lessons, how about the one in the appendix?!)&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Designing is &lt;em>fundamentally&lt;/em> about taking things apart. It&amp;rsquo;s about taking
things apart &lt;em>in such a way&lt;/em> that they can be put back together. i.e.
Separating into things that can be composed.&amp;rdquo;&lt;/p>
&lt;ul>
&lt;li>Rich Hickey, &amp;ldquo;&lt;a href="https://www.youtube.com/watch?v=QCwqnjxqfmY">Design, Composition, and Performance&lt;/a>&amp;rdquo;, 2013&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> | tr A-Z a-z | sort | uniq -c | sort -rn | sed 10q
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Douglas McIlroy, &lt;a href="https://dl.acm.org/doi/10.1145/5948.315654">Communications of the ACM&lt;/a>, 1986&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;a href="#the-pipeline-that-douglas-built">The Pipeline that Douglas Built&lt;/a>&lt;/li>
&lt;li>&lt;a href="#take-apart-semantics-idioms-functions">Take Apart! Semantics/Idioms -&amp;gt; Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#play-semantics-functions-ooh-what-if-i-dot-dot-dot">Play! Semantics -&amp;gt; Functions -&amp;gt; &amp;ldquo;Ooh, what if I&amp;hellip;&amp;quot;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compose-again-semantics-functions-play-grand-new-pipeline">Compose Again! Semantics -&amp;gt; Functions -&amp;gt; Play -&amp;gt; Grand New Pipeline&lt;/a>&lt;/li>
&lt;li>&lt;a href="#addendum-remarkable-aspects-of-doug-s-o-dot-g-dot-pipeline">Addendum: Remarkable aspects of Doug&amp;rsquo;s O.G. pipeline&lt;/a>&lt;/li>
&lt;li>&lt;a href="#appendix-an-unexpected-masterclass">Appendix: an unexpected masterclass!&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-danger-lurking-in-the-pipes">The danger lurking in the pipes&lt;/a>&lt;/li>
&lt;li>&lt;a href="#backstory">Backstory&lt;/a>&lt;/li>
&lt;li>&lt;a href="#postscript">Postscript&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>Previously: &lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-0-intro/">Shell ain&amp;rsquo;t a bad place to FP: part 0/N&lt;/a>&lt;/p></description><content>&lt;p>Or, &lt;em>&lt;strong>the one in which we &amp;ldquo;take apart&amp;rdquo; Douglas McIlroy&amp;rsquo;s pipeline from 1986.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Doing so teaches an object lesson about the essence of modular, composable,
functional architecture. And things start to really heat up when it dawns on
us, how a good set of standard parts can be used to express totally different
ideas &lt;em>just by composing them in different ways&lt;/em>.&lt;/p>
&lt;p>(Edit 2022-03-10: speaking of lessons, how about the one in the appendix?!)&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Designing is &lt;em>fundamentally&lt;/em> about taking things apart. It&amp;rsquo;s about taking
things apart &lt;em>in such a way&lt;/em> that they can be put back together. i.e.
Separating into things that can be composed.&amp;rdquo;&lt;/p>
&lt;ul>
&lt;li>Rich Hickey, &amp;ldquo;&lt;a href="https://www.youtube.com/watch?v=QCwqnjxqfmY">Design, Composition, and Performance&lt;/a>&amp;rdquo;, 2013&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> | tr A-Z a-z | sort | uniq -c | sort -rn | sed 10q
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Douglas McIlroy, &lt;a href="https://dl.acm.org/doi/10.1145/5948.315654">Communications of the ACM&lt;/a>, 1986&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;a href="#the-pipeline-that-douglas-built">The Pipeline that Douglas Built&lt;/a>&lt;/li>
&lt;li>&lt;a href="#take-apart-semantics-idioms-functions">Take Apart! Semantics/Idioms -&amp;gt; Functions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#play-semantics-functions-ooh-what-if-i-dot-dot-dot">Play! Semantics -&amp;gt; Functions -&amp;gt; &amp;ldquo;Ooh, what if I&amp;hellip;&amp;quot;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compose-again-semantics-functions-play-grand-new-pipeline">Compose Again! Semantics -&amp;gt; Functions -&amp;gt; Play -&amp;gt; Grand New Pipeline&lt;/a>&lt;/li>
&lt;li>&lt;a href="#addendum-remarkable-aspects-of-doug-s-o-dot-g-dot-pipeline">Addendum: Remarkable aspects of Doug&amp;rsquo;s O.G. pipeline&lt;/a>&lt;/li>
&lt;li>&lt;a href="#appendix-an-unexpected-masterclass">Appendix: an unexpected masterclass!&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-danger-lurking-in-the-pipes">The danger lurking in the pipes&lt;/a>&lt;/li>
&lt;li>&lt;a href="#backstory">Backstory&lt;/a>&lt;/li>
&lt;li>&lt;a href="#postscript">Postscript&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>Previously: &lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-0-intro/">Shell ain&amp;rsquo;t a bad place to FP: part 0/N&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="the-pipeline-that-douglas-built">The Pipeline that Douglas Built&lt;/h2>
&lt;p>Douglas McIlroy famously (infamously?) wrote the following in reply to a
problem posed by Jon Bentley for his column &lt;em>&amp;ldquo;Programming pearls: a literate
program&amp;rdquo;&lt;/em> (&lt;em>Communications of the ACM&lt;/em> magazine, June 1986, Vol. 29, No. 6).&lt;/p>
&lt;p>I first heard of it some years ago in &lt;a href="https://leancrew.com/all-this/2011/12/more-shell-less-egg/">More Shell Less Egg&lt;/a>, and saw it again
in the book &lt;a href="https://www.oreilly.com/library/view/classic-shell-scripting/0596005954/">Classic Shell Scripting&lt;/a> (which taught me much of my shell-fu).
The original was not online then. Now I see the ACM has kindly &lt;a href="https://dl.acm.org/doi/10.1145/5948.315654">published it&lt;/a>
along with the rest of their archives!&lt;/p>
&lt;p>Here it is, lightly paraphrased:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># Problem statement (word frequency):&lt;/span>
&lt;span style="color:#75715e">#&lt;/span>
&lt;span style="color:#75715e"># - Read a file of text&lt;/span>
&lt;span style="color:#75715e"># - Determine the n most frequently-used words&lt;/span>
&lt;span style="color:#75715e"># - Print out a sorted list of all the words, along with their frequencies&lt;/span>
&lt;span style="color:#75715e"># Douglas McIlroy&amp;#39;s answer&lt;/span>
&lt;span style="color:#75715e"># 1. Transliterate complement (-c) of words into newlines,&lt;/span>
&lt;span style="color:#75715e"># squeezing out (-s) duplicates&lt;/span>
tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> |
&lt;span style="color:#75715e"># 2. Transliterate uppercase to lowercase&lt;/span>
tr A-Z a-z |
&lt;span style="color:#75715e"># 3. Sort to bring identical words together&lt;/span>
sort |
&lt;span style="color:#75715e"># 4. Replace each run of duplicate words with&lt;/span>
&lt;span style="color:#75715e"># a single representative, and include a count&lt;/span>
uniq -c |
&lt;span style="color:#75715e"># 5. Sort reverse (-r), numeric (-n)&lt;/span>
sort -rn |
&lt;span style="color:#75715e"># 6. Pass through stream editor; quit after printing the&lt;/span>
&lt;span style="color:#75715e"># the first 10 lines received&lt;/span>
sed 10q
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here I am, punching the Bash manual page through it&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">man bash |
tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> | tr A-Z a-z |
sort | uniq -c | sort -rn |
sed 10q
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and here are the top 10 words by frequency.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">4200 the
1822 is
1251 to
1221 a
1147 of
869 if
805 and
570 shell
570 in
563 command
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;ldquo;&lt;em>Coolcoolcoolcool nodoubt nodoubt&amp;hellip; So, uh&amp;hellip; that&amp;rsquo;s it?&lt;/em>&amp;rdquo;&lt;/p>
&lt;h2 id="take-apart-semantics-idioms-functions">Take Apart! Semantics/Idioms -&amp;gt; Functions&lt;/h2>
&lt;p>It&amp;rsquo;s worth observing that the &lt;em>same&lt;/em> tools composed in &lt;em>different&lt;/em> ways express
&lt;em>totally different&lt;/em> concepts. &lt;code>sort&lt;/code> just sorts. &lt;code>uniq&lt;/code> just returns uniques.
&lt;em>But&lt;/em> &lt;code>sort | uniq&lt;/code> is an idiom for &lt;em>set of things&lt;/em>. Whereas &lt;code>sort | uniq -c | sort -rn&lt;/code> is an idiom for &lt;em>frequency distribution&lt;/em>.&lt;/p>
&lt;p>Now&amp;hellip;&lt;/p>
&lt;p>What if we use Bash functions to name the idioms we see in McIlroy&amp;rsquo;s pipeline?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">flatten_paragraphs&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># English-only for easy explanation, but can be more general&lt;/span>
tr -cs A-Za-z &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
tokenise_lowercase&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># Transliterate uppercase to lowercase&lt;/span>
tr A-Z a-z
&lt;span style="color:#f92672">}&lt;/span>
frequencies&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># Produce frequency distribution of input&lt;/span>
sort | uniq -c | sort -rn
&lt;span style="color:#f92672">}&lt;/span>
take_n&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># Given a number n, return those many lines of input&lt;/span>
&lt;span style="color:#75715e"># or 10 lines by default, if n is not specified.&lt;/span>
sed &lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>10&lt;span style="color:#e6db74">}&lt;/span>q
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And what if we update the pipeline with &lt;em>function calls&lt;/em> like this?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">man bash |
flatten_paragraphs |
tokenise_lowercase |
frequencies |
take_n &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yes, we get the same result!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">4200 the
1822 is
1251 to
1221 a
1147 of
869 if
805 and
570 shell
570 in
563 command
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yes, yes, &lt;em>&lt;strong>YES&lt;/strong>&lt;/em>! Functions + pipes = mind blown!&lt;/p>
&lt;h2 id="play-semantics-functions-ooh-what-if-i-dot-dot-dot">Play! Semantics -&amp;gt; Functions -&amp;gt; &amp;ldquo;Ooh, what if I&amp;hellip;&amp;rdquo;&lt;/h2>
&lt;p>Now that we lifted out a couple of text processing functions, we can try to
make &lt;em>more&lt;/em> text processing functions. Here are some examples.&lt;/p>
&lt;p>(Edit 2022-03-10: the &amp;ldquo;clever&amp;rdquo; mkfifo-ery contains dangers I did not know of.
More at the bottom, in the appendix.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">sort_dictionary&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sort -b -d -k2
&lt;span style="color:#f92672">}&lt;/span>
sort_rhyme&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
rev | sort -b -d | rev
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e"># eliminate stop-words&lt;/span>
drop_stopwords&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local stopwords&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>&lt;span style="color:#e6db74">&amp;#34;the,is,to,a,of,if,and,in,or,be,by,not,with,for,when,it&amp;#34;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>
local grep_pattern&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>tr , &lt;span style="color:#e6db74">&amp;#39;\|&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>stopwords&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
grep -v -E &lt;span style="color:#e6db74">${&lt;/span>grep_pattern&lt;span style="color:#e6db74">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e"># n-grams&lt;/span>
butlast_n&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># utility for picking appropriate collection of n-grams&lt;/span>
head -n -&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#66d9ef">:-&lt;/span>0&lt;span style="color:#e6db74">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
bigram&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># we need intermediate state, but we can make it stream,&lt;/span>
&lt;span style="color:#75715e"># instead of accumulating in temp files&lt;/span>
mkfifo bigram_buffer
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>tail +2 &amp;gt; bigram_buffer&lt;span style="color:#f92672">)&lt;/span> |
paste - bigram_buffer |
&lt;span style="color:#75715e"># take all but the last entry as it is not a bigram&lt;/span>
butlast_n &lt;span style="color:#ae81ff">1&lt;/span>
rm bigram_buffer
&lt;span style="color:#f92672">}&lt;/span>
trigram&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># we need intermediate state, but we can make it stream,&lt;/span>
&lt;span style="color:#75715e"># instead of accumulating in temp files&lt;/span>
mkfifo trigram_buffer_one trigram_buffer_two
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>tail +2 &amp;gt; trigram_buffer_one&lt;span style="color:#f92672">)&lt;/span> |
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>tail +3 &amp;gt; trigram_buffer_two&lt;span style="color:#f92672">)&lt;/span> |
paste - trigram_buffer_one trigram_buffer_two |
&lt;span style="color:#75715e"># take all but the last 2 entries as they are not trigrams&lt;/span>
butlast_n &lt;span style="color:#ae81ff">2&lt;/span>
rm trigram_buffer_one trigram_buffer_two
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Clearly there is a lot to explore about functions and pipelines and other
techniques in this code. We will do deep dives in upcoming posts. For now
just know that Bash functions&amp;hellip;&lt;/p>
&lt;ul>
&lt;li>name a group of shell statements,&lt;/li>
&lt;li>can be composed with pipes&lt;/li>
&lt;li>thus intermix with regular shell tools, and&lt;/li>
&lt;li>can help create domain-specific abstractions out of domain-agnostic ones.&lt;/li>
&lt;/ul>
&lt;p>But before we go there, indulge me and my &lt;em>Oh, and One More Thing (TM)&lt;/em> &amp;hellip;&lt;/p>
&lt;h2 id="compose-again-semantics-functions-play-grand-new-pipeline">Compose Again! Semantics -&amp;gt; Functions -&amp;gt; Play -&amp;gt; Grand New Pipeline&lt;/h2>
&lt;p>What&amp;rsquo;s the point of making a text processing library of functions if we don&amp;rsquo;t
process any text?&lt;/p>
&lt;p>Well&amp;hellip;&lt;/p>
&lt;ul>
&lt;li>Start a new shell session.&lt;/li>
&lt;li>Copy-paste all the Bash functions above into it.&lt;/li>
&lt;li>Then copy-paste this pipeline and&lt;/li>
&lt;li>Hit Enter!&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># I assume you have Bash version 4+.&lt;/span>
man bash |
&lt;span style="color:#75715e"># pre-process&lt;/span>
flatten_paragraphs |
tokenise_lowercase |
drop_stopwords |
&lt;span style="color:#75715e"># cache raw pre-processed data, if we need to re-analyse later&lt;/span>
tee /tmp/bash_manpage_raw_tokens.txt |
&lt;span style="color:#75715e"># cache various views or compressions of the raw data&lt;/span>
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>sort_dictionary | uniq &amp;gt; /tmp/bash_manpage_sorted_as_dictionary.txt&lt;span style="color:#f92672">)&lt;/span> |
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>sort_rhyme | uniq &amp;gt; /tmp/bash_manpage_sorted_as_rhyme.txt&lt;span style="color:#f92672">)&lt;/span> |
&lt;span style="color:#75715e"># accumulate various analyses of the OG raw data&lt;/span>
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>frequencies &amp;gt; /tmp/bash_manpage_token_freqs.txt&lt;span style="color:#f92672">)&lt;/span> |
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>bigram | frequencies &amp;gt; /tmp/bash_manpage_bigram_freqs.txt&lt;span style="color:#f92672">)&lt;/span> |
tee &amp;gt;&lt;span style="color:#f92672">(&lt;/span>trigram | frequencies &amp;gt; /tmp/bash_manpage_trigram_freqs.txt&lt;span style="color:#f92672">)&lt;/span> |
take_n
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And why not experiment?!&lt;/p>
&lt;p>Reorder it! Remove parts of it! Change parts of it! Give it 10 GiB of input!&lt;/p>
&lt;p>Play and learn!!!&lt;/p>
&lt;p>(#protip: The shell can auto-complete functions. Type &lt;em>flat&lt;/em> and hit &lt;em>TAB&lt;/em>,
and you should get a completion for &lt;em>flatten_paragraphs&lt;/em>.)&lt;/p>
&lt;h2 id="addendum-remarkable-aspects-of-doug-s-o-dot-g-dot-pipeline">Addendum: Remarkable aspects of Doug&amp;rsquo;s O.G. pipeline&lt;/h2>
&lt;p>The UNIX tools philosophy is clearly at work. &lt;code>sort&lt;/code> just sorts, &lt;code>uniq&lt;/code> just
returns uniques, pipes connect parts. Ho hum.&lt;/p>
&lt;p>The things I &lt;em>do&lt;/em> find remarkable are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Now the year is 2022, i.e. McIlroy wrote the program about 4 &lt;em>decades&lt;/em> ago.
It continues to edify, meaning the ideas it contains have a timeless quality.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>It also works as-is&lt;/em>, on my cheap Thinkpad running a GNU Linux (Ubuntu),
even though the original code was written for a UNIX that might live only
in a museum today (or maybe in your bank). Odds look good that come 2036, it
will continue to still work as-is on mainstream boxen.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It is plain text, and so eminently portable. (I slapped it into the org-mode
file of this blog post, evaluated it via org-babel, and captured the results
inline. How? Because Emacs org-babel can simply &amp;ldquo;shell out&amp;rdquo;; i.e. make a
standard request to a standard shell to evaluate the program and have the
shell process return any result in a standard way.)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I bet it runs &lt;em>way&lt;/em> faster now because my box is a supercomputer v/s the
UNIX boxen of that era.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pipes remove the burden of explicit state handling. Oh, also, Douglas McIlroy
invented UNIX pipes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The entire composition is itself a function.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>map&lt;/code> (tokenise), &lt;code>filter&lt;/code> (uniquify), &lt;code>reduce&lt;/code> (frequency distribution),
and early termination (&lt;code>take&lt;/code> first 10) are &lt;em>automatic&lt;/em>, needing no special
machinery.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It is an abstract computation that is independent of data source/sink. We
can hook into any I/O combination of sockets, or fifo pipes, or files on
disk without modifying the pipeline code&amp;mdash;much like Clojure transducers
or monadic I/O in Haskell land.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Most importantly&lt;/em>, a rank amateur like me could figure out each part &lt;em>and&lt;/em>
the whole in one sitting. It is eminently doable because:&lt;/p>
&lt;ul>
&lt;li>each sub part is understandable in isolation &lt;em>and&lt;/em>&lt;/li>
&lt;li>the whole is amenable to incremental as well as large-scale adaptation,&lt;/li>
&lt;li>in playful, interactive, low-risk ways.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>I was clueless then and had to dig through manpages and flail about at the
command line. It took me a while to grok the function of each tool and how
it is applied to the text processing problem.&lt;/p>
&lt;p>If you haven&amp;rsquo;t already, I&amp;rsquo;d say bear that small cost, because it teaches a
priceless lesson in modular, composable, functional architecture.&lt;/p>
&lt;p>Plus, why not step up one&amp;rsquo;s shell-fu?&lt;/p>
&lt;h2 id="appendix-an-unexpected-masterclass">Appendix: an unexpected masterclass!&lt;/h2>
&lt;p>My head is exploding. Prof. McIlroy emailed me some remarks. (There is a
backstory, but first the important stuff.)&lt;/p>
&lt;h3 id="the-danger-lurking-in-the-pipes">The danger lurking in the pipes&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">(Emails redacted to stymie spambots.)
----- Original message -----
From: Douglas McIlroy &amp;lt;Email at his web page. Link posted below.&amp;gt;
To: Aditya Athalye &amp;lt;Email at this web page. See footer.&amp;gt;
Subject: Musings on your blog
Date: Wednesday, March 09, 2022 8:16 PM
Aditya,
A reader might complain that the bigram example in your blog
can be done more efficiently, with a similar amount of typing,
by a sed script instead of mkfifo, tee, and paste:
sed -n &amp;#39;1bx; H; g; s/\n/ /p; s/.* //; :x; h&amp;#39;
A slightly different example is immune to this charge:
trap &amp;#34;rm -f fifo&amp;#34; 0 HUP TERM PIPE INT
mkfifo fifo
sort |
uniq |
tee &amp;gt;(rev | sort &amp;gt;fifo) |
join -o 1.1 - fifo &amp;gt;palindromes
But ... join can&amp;#39;t move until rev|sort produces output, so
essentially the whole word list piles up in its input pipe.
If there&amp;#39;s not enough buffer space, deadlock will occur.
The moral of this tale is that loops in the (undirected)
graph of a pipe network pose a hazard of deadlock if some
pipe queue necessarily suffers unbounded growth. This
hazard manifests in the palindrome example but not in
the bigram example.
Sidelight. Buffering by C&amp;#39;s stdio package can cause
deadlock in a feedback loop. A process that buffers its
output will starve if it needs feedback from stuff that&amp;#39;s
waiting in its output buffer. stdio&amp;#39;s buffering is evil!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Prof. McIlroy also pointed me to his notes on coroutine-based programs
(examples of stream processing in Unix).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">In case you haven&amp;#39;t already seen it,
https://www.cs.dartmouth.edu/~doug/sieve/sieve.pdf
exhibits some unusual plumbing.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The PDF is available at &lt;a href="https://www.cs.dartmouth.edu/~doug/">his Dartmouth College home page&lt;/a>,
which has other fun stuff too.&lt;/p>
&lt;h3 id="backstory">Backstory&lt;/h3>
&lt;p>I habitually cold-email people if something they did or said moved me in some
constructive way. So, I wrote a little thank you note to Prof. McIlroy after
posting this blog entry (nobody thinks straight at 3 AM).&lt;/p>
&lt;p>He replied! We exchanged a couple of emails. &lt;em>&amp;ldquo;That was &lt;strong>so cool&lt;/strong>!&amp;quot;&lt;/em> thought I,
and went back to life as usual.&lt;/p>
&lt;p>Yesterday he emailed these follow-up remarks! A nice little masterclass in
Unix programming that I&amp;rsquo;m so pleased to share here, with Prof. McIlroy&amp;rsquo;s
gracious permission.&lt;/p>
&lt;h3 id="postscript">Postscript&lt;/h3>
&lt;p>Wow, this is one of the best emails I&amp;rsquo;ve ever received! The reader&amp;rsquo;s
complaints are warranted and deserved.&lt;/p>
&lt;p>I was fooling around with mkfifo and accidentally discovered it &amp;ldquo;worked&amp;rdquo;
after a fashion. &amp;ldquo;What&amp;rsquo;s the buffering story?&amp;rdquo; crossed my mind, but I didn&amp;rsquo;t
find out. I&amp;rsquo;m also slapping my forehead for not using &lt;code>trap&lt;/code> to auto-clean
the pipes. And needless to say, &lt;a href="https://github.com/adityaathalye/shite/blob/5f87aa0df095a1b5af914117aaa34bf63c67ec4d/shite%5Futils.sh#L155">my sed-fu&lt;/a> is weak. Brown belt at best :)&lt;/p>
&lt;p>I rue the fact that I haven&amp;rsquo;t paid due attention to The Machine. I can write
Clojure to make a living, but can&amp;rsquo;t write C to save my life :))&lt;/p>
&lt;p>So now this excellent complaint leaves me no choice, but to crack open my
long-unused copies of the K&amp;amp;R book and The Unix Programming Environment.&lt;/p>
&lt;p>&lt;em>Thank you so much for taking the time to teach me, Professor!&lt;/em>&lt;/p>
&lt;hr>
&lt;p>Next up: Part 2/N: Deep-dive into bash functions and function design techniques&lt;/p>
&lt;ul>
&lt;li>Using functions to craft one’s own Bytes-sized UNIX tools&lt;/li>
&lt;li>Using them interactively like regular UNIX tools&lt;/li>
&lt;li>maybe more&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>The ol' noodle is noodlin' over it. Stay tooned!&lt;/p></content></item><item><title>Shell ain't a bad place to FP: part 0/N: Introduction</title><link>/posts/shell-aint-a-bad-place-to-fp-part-0-intro/</link><pubDate>Wed, 23 Feb 2022 01:55:11 +0530</pubDate><guid>/posts/shell-aint-a-bad-place-to-fp-part-0-intro/</guid><description>&lt;p>Or, &lt;em>&lt;strong>Supremely Functional Bash Programming&lt;/strong>, an exploration in N parts&amp;hellip;&lt;/em>&lt;/p>
&lt;p>Once upon a time, while fiddling with a log processing shell pipeline, it hit me
that the UNIX Way is a Surprisingly Functional Way, and so Functional Programming
(FP) and Bash must be a natural fit. They fit. The world was never the same again.&lt;/p>
&lt;p>Now I believe it so much, that I will go on a limb and assert that it is
highly inappropriate to write imperative-style Bash when we can just as easily
write &lt;em>supremely&lt;/em> functional Bash. Why? Because it makes for supremely &lt;em>better&lt;/em>
Bash (more reusable, more composable, more scalable, more enjoyable).&lt;/p>
&lt;p>Yes, I truly believe.&lt;/p>
&lt;p>Yes, I&amp;rsquo;m sane.&lt;/p>
&lt;p>No? Well OK, humour me&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;a href="#obligatory-mea-culpa">Obligatory mea culpa&lt;/a>&lt;/li>
&lt;li>&lt;a href="#an-outline-of-the-n-parts">An outline of the &amp;ldquo;N&amp;rdquo; parts&lt;/a>&lt;/li>
&lt;li>&lt;a href="#prelude-seeing-the-unix-tools-philosophy-as-a-functional-design-philosophy">Prelude: Seeing the UNIX tools philosophy as a functional design philosophy&lt;/a>&lt;/li>
&lt;li>&lt;a href="#screw-that-show-me-your-code">&amp;ldquo;Screw that, show me your code&amp;rdquo;&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted --></description><content>&lt;p>Or, &lt;em>&lt;strong>Supremely Functional Bash Programming&lt;/strong>, an exploration in N parts&amp;hellip;&lt;/em>&lt;/p>
&lt;p>Once upon a time, while fiddling with a log processing shell pipeline, it hit me
that the UNIX Way is a Surprisingly Functional Way, and so Functional Programming
(FP) and Bash must be a natural fit. They fit. The world was never the same again.&lt;/p>
&lt;p>Now I believe it so much, that I will go on a limb and assert that it is
highly inappropriate to write imperative-style Bash when we can just as easily
write &lt;em>supremely&lt;/em> functional Bash. Why? Because it makes for supremely &lt;em>better&lt;/em>
Bash (more reusable, more composable, more scalable, more enjoyable).&lt;/p>
&lt;p>Yes, I truly believe.&lt;/p>
&lt;p>Yes, I&amp;rsquo;m sane.&lt;/p>
&lt;p>No? Well OK, humour me&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;a href="#obligatory-mea-culpa">Obligatory mea culpa&lt;/a>&lt;/li>
&lt;li>&lt;a href="#an-outline-of-the-n-parts">An outline of the &amp;ldquo;N&amp;rdquo; parts&lt;/a>&lt;/li>
&lt;li>&lt;a href="#prelude-seeing-the-unix-tools-philosophy-as-a-functional-design-philosophy">Prelude: Seeing the UNIX tools philosophy as a functional design philosophy&lt;/a>&lt;/li>
&lt;li>&lt;a href="#screw-that-show-me-your-code">&amp;ldquo;Screw that, show me your code&amp;rdquo;&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;hr>
&lt;h2 id="obligatory-mea-culpa">Obligatory mea culpa&lt;/h2>
&lt;p>Because I&amp;rsquo;m am going to lazy-stream this in N parts. Because my original post
was growing to &amp;ldquo;never gonna ship&amp;rdquo; size. But &lt;em>&lt;strong>not&lt;/strong>&lt;/em> because &amp;ldquo;Bash ain&amp;rsquo;t a &lt;em>real&lt;/em>
programming language&amp;rdquo;. (Besides, in our post-reality world, we get to make
our own reality.)&lt;/p>
&lt;h3 id="nothing-here-will-be-novel-dot">Nothing here will be novel.&lt;/h3>
&lt;ul>
&lt;li>&lt;em>&lt;strong>I&amp;rsquo;ve not invented anything that follows.&lt;/strong>&lt;/em> There are too many influences to
enumerate fully. I&amp;rsquo;ll provide references as I go along.&lt;/li>
&lt;li>&lt;em>&lt;strong>I expect to revise&lt;/strong>&lt;/em>, correct, add to this series as I learn more over time.&lt;/li>
&lt;li>&lt;em>&lt;strong>Code in the post assumes Bash 4+&lt;/strong>&lt;/em>, because that&amp;rsquo;s what I&amp;rsquo;ve been using
over the last 8-odd years.&lt;/li>
&lt;/ul>
&lt;h3 id="your-mileage-may-vary-dot">Your Mileage May Vary.&lt;/h3>
&lt;ul>
&lt;li>&lt;em>&lt;strong>The Bash code will be both message and medium.&lt;/strong>&lt;/em> but I will describe
general FP thinking, and Bash sure isn&amp;rsquo;t the only medium. Please replicate
solutions in your favourite language (in a UNIX-like way)!&lt;/li>
&lt;li>&lt;em>&lt;strong>I won&amp;rsquo;t go crazy with Bash-isms&lt;/strong>&lt;/em>, so the ideas and most of the code should
generalise to most UNIXy shells. That said, I haven&amp;rsquo;t used other shells to
make equally confident claims about FP in them.&lt;/li>
&lt;/ul>
&lt;h3 id="fp-suffuses-my-very-being-dot-m">&lt;strong>FP &lt;a href="http://evalapply.org/posts/what-makes-functional-programming-systems-functional/">suffuses my very being&lt;/a>.&lt;/strong> \m/&lt;/h3>
&lt;ul>
&lt;li>And I&amp;rsquo;m fairly confident the FP ideas will translate broadly, because I use
them all the time; in my code (Clojure, APL, Ruby, JS, Python, SML&amp;hellip;), in
my designs for logging systems, infra-as-code systems, CI/CD systems, as
well as designing human/communication workflows for teams.&lt;/li>
&lt;li>But it&amp;rsquo;s possible I&amp;rsquo;ve lived my life all wrong.&lt;/li>
&lt;/ul>
&lt;h2 id="an-outline-of-the-n-parts">An outline of the &amp;ldquo;N&amp;rdquo; parts&lt;/h2>
&lt;p>This (zeroth) post is about why the UNIX Way is the way of functional-style
design &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. &lt;em>&lt;code>N&lt;/code>&lt;/em> more posts are brewing, with examples and techniques.
Likely one per topic:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A &lt;em>rad&lt;/em> example from 1986 to motivate the rest of the series.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deep-dive into bash functions and function design techniques&lt;/p>
&lt;ul>
&lt;li>Using functions to craft one&amp;rsquo;s own Bytes-sized UNIX tools&lt;/li>
&lt;li>Using them interactively like regular UNIX tools&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pipelining all the things&lt;/p>
&lt;ul>
&lt;li>How we automatically get map / filter / reduce / early termination&lt;/li>
&lt;li>Automatic streaming (regular pipes, tee, named pipes etc&amp;hellip;)&lt;/li>
&lt;li>Ways to do pipeline-friendly domain design, and to translate that into
pipeline-friendly functions.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Avoiding manual state management with intelligent use of:&lt;/p>
&lt;ul>
&lt;li>Variables, scopes, program invariants&lt;/li>
&lt;li>Command substitution&lt;/li>
&lt;li>Process substitution&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Declarative programming&lt;/p>
&lt;ul>
&lt;li>Templating with heredocs and herestrings&lt;/li>
&lt;li>Trickshots with things like &lt;code>seq&lt;/code>, &lt;code>paste&lt;/code> etc.&lt;/li>
&lt;li>Reasonable uses of pattern matching&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Environment isolation in detail&lt;/p>
&lt;ul>
&lt;li>Lists and sub-shells&lt;/li>
&lt;li>in Pipelines&lt;/li>
&lt;li>Session portability&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Designing idempotent / restart-friendly solutions&lt;/p>
&lt;ul>
&lt;li>Because things can and will fail.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Maybe parallelism&lt;/p>
&lt;ul>
&lt;li>Mainly because I haven&amp;rsquo;t &lt;em>had to&lt;/em> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> write parallel Bash, but it will
be fun to mess with.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Maybe sundry topics like associative arrays (Bash-only), job control,
namespacing, metaprogramming, flame-bait like &amp;ldquo;pipes are monads&amp;rdquo; etc.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="prelude-seeing-the-unix-tools-philosophy-as-a-functional-design-philosophy">Prelude: Seeing the UNIX tools philosophy as a functional design philosophy&lt;/h2>
&lt;p>The many remarkable aspects of UNIX Nature were discovered over half a century
worth of versions, revisions, disasters, and reincarnations. While many avatars
of UNICES and UNIX-likes have come and gone, the UNIX Way (articulated by the
1990s) has thrived through the ravages of time. Here it is, embodied in the
form of the UNIX Tools Philosophy.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;em>&lt;strong>Most importantly, do one thing&lt;/strong>&lt;/em>, and do it well (just like a function).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Consume and emit &lt;em>&lt;strong>plain data&lt;/strong>&lt;/em> (just like a function).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>Output the same data format as is received at input&lt;/strong>&lt;/em> (formerly only plain
lines of text, but now also structured literal data like JSON, EDN etc.)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>Don&amp;rsquo;t be chatty&lt;/strong>&lt;/em> (i.e. avoid side-effects, again, just like a function).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Be line-oriented, which design choice turns out to be &lt;em>&lt;strong>naturally streaming&lt;/strong>&lt;/em>,
with &lt;em>&lt;strong>automatic support for map/filter/reduce&lt;/strong>&lt;/em>, which we will use a lot.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Favour &lt;em>&lt;strong>universal composition&lt;/strong>&lt;/em> via standard interfaces like file descriptors,
standard IN/OUT/ERROR, line-orientation, and UNIX pipes (quite monadic, an
argument for much later).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Be as &lt;em>&lt;strong>general-purpose&lt;/strong>&lt;/em> as possible for wide reusability, in any context.
This pushes tools away from imposing internal structure on input data, as
also from maintaining persistent or shared internal state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ideally have sane behaviour like environment isolation, idempotence, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Last but not least, when out-of-the-box solutions are not good enough, it
encourages us to detour to building our own tools. And these can be simple
Bash functions, usable interactively at the command line, just like full
standalone programs!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Of course, practice can diverge from the ideal, but not by too much (many tools
have to work with stateful objects like files and sockets, some may rely on
lock-files, some should be idempotent but aren&amp;rsquo;t, others may grow to do more
than one thing and do everything badly etc.). Besides, not even Haskellers
escape this reality, so there.&lt;/p>
&lt;p>It stands that the UNIX Way strongly encourages us to create laser-focused,
composable, purely functional, data-flow oriented programs that we can remix
at will into surprisingly powerful solutions with surprisingly little ceremony.&lt;/p>
&lt;p>This &lt;em>Way&lt;/em> has proven to be very useful at scales several orders of magnitude
apart; from in-program 1-liner functions, to 1 kilobyte tools, to operating
systems, to planet-wide distributed systems. This unreasonable effectiveness
is why UNIX People have long valued these values.&lt;/p>
&lt;h2 id="screw-that-show-me-your-code">&amp;ldquo;Screw that, show me your code&amp;rdquo;&lt;/h2>
&lt;p>Sorry! I feel ya&amp;hellip; no code, no dice. Here is some of my FP-style Bash.
I plan to crib liberally from these to illustrate the posts-to-come.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://github.com/adityaathalye/bash-toolkit">bash-toolkit&lt;/a>&lt;/strong>:
a &amp;ldquo;Swiss Army Toolkit&amp;rdquo; of functions I&amp;rsquo;ve been accumulating over the years.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://github.com/adityaathalye/oxo">oxo&lt;/a>&lt;/strong>:
a retro-style noughts and crosses game in Bash (and it speaks!).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Next up: &lt;strong>&lt;a href="https://evalapply.org/posts/shell-aint-a-bad-place-to-fp-part-1-doug-mcilroys-pipeline/">Shell ain&amp;rsquo;t a bad place to FP: part 1/N&lt;/a>&lt;/strong>
in which we take apart Douglas McIlroy&amp;rsquo;s famous pipeline from 1986, to
motivate the rest of the series. &amp;ldquo;Take apart&amp;rdquo; in the sense of &amp;ldquo;Design is
about taking things apart.&amp;rdquo;. A most respectful sense.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>May the Source be with us.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Recently I went on for a bit in general about &lt;a href="https://www.evalapply.org/posts/what-makes-functional-programming-systems-functional/">what does it even mean to be &amp;ldquo;functional&amp;rdquo;?&lt;/a> Read that if it pleases you, because it informs my approach to &lt;em>Supremely Functional&lt;/em> Bash programming.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>There was the one time I could have, at a $DAYJOB, but I was quite green, and had deadline, and it was a one time log analysis thing, and I a large EC2 box to waste, which I hogged for half a day, and came away stunned that my crappy shell pipeline chewed through ~600 GiB (gzipped) without crashing anything.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content></item><item><title>Poor man's Reader App with Pandoc and Bash</title><link>/posts/reader-app-pandoc-bash/</link><pubDate>Thu, 10 Feb 2022 22:10:43 +0530</pubDate><guid>/posts/reader-app-pandoc-bash/</guid><description>&lt;p>Throwback, June 27, 2020.&lt;/p>
&lt;p>Every so often, I want to avoid opening a website in a browser, for &amp;hellip; reasons.&lt;/p>
&lt;p>Curl alone presents too much html. I want to try and read stuff.&lt;/p>
&lt;p>Today, I was playing with Igor Chubin&amp;rsquo;s &lt;strong>awesome&lt;/strong> terminal services (wttr.in,
cht.sh etc.), and it hit me:&lt;/p>
&lt;p>&amp;ldquo;WAIT, there&amp;rsquo;s pandoc, what if I just &amp;hellip; &amp;quot;&lt;/p></description><content>&lt;p>Throwback, June 27, 2020.&lt;/p>
&lt;p>Every so often, I want to avoid opening a website in a browser, for &amp;hellip; reasons.&lt;/p>
&lt;p>Curl alone presents too much html. I want to try and read stuff.&lt;/p>
&lt;p>Today, I was playing with Igor Chubin&amp;rsquo;s &lt;strong>awesome&lt;/strong> terminal services (wttr.in,
cht.sh etc.), and it hit me:&lt;/p>
&lt;p>&amp;ldquo;WAIT, there&amp;rsquo;s pandoc, what if I just &amp;hellip; &amp;quot;&lt;/p>
&lt;hr>
&lt;p>&amp;hellip;
&amp;hellip;
&amp;hellip; and an hour later&amp;hellip; a terrible idea manifested itself.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">www_to_md&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
pandoc --wrap&lt;span style="color:#f92672">=&lt;/span>none -f html -t markdown &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
drop_noise&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># remove pesky divs&lt;/span>
grep -v -E &lt;span style="color:#e6db74">&amp;#34;(&amp;lt;div|&amp;lt;/div).*[&amp;gt;]?|*.&amp;gt;&amp;#34;&lt;/span> |
&lt;span style="color:#75715e"># squeeze multiple blank lines into one&lt;/span>
cat -s
&lt;span style="color:#f92672">}&lt;/span>
cache_site&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local sitecache&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1:?&lt;span style="color:#e6db74">&amp;#39;Fail. Path to create cache.&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local mdfilename&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2&lt;span style="color:#66d9ef">:-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;this.md&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local evict_cache_qmark&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>3&lt;span style="color:#66d9ef">:-&lt;/span>no&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
mkdir -p &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -f &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mdfilename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>evict_cache_qmark&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;span style="color:#66d9ef">then&lt;/span> tee
&lt;span style="color:#66d9ef">else&lt;/span> tee &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mdfilename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
panwww&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local siteurl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>1&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local evict_cache_qmark&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>2&lt;span style="color:#66d9ef">:-&lt;/span>no&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local sitename&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>siteurl/http*:&lt;span style="color:#ae81ff">\/\/&lt;/span>/www.&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local sitecache&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/tmp/panwwwcache/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local mdfilename&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;this.md&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[[&lt;/span> -f &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mdfilename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>evict_cache_qmark&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;span style="color:#66d9ef">then&lt;/span> local cmd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;cat &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mdfilename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span> local cmd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;www_to_md &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>siteurl&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
$cmd | drop_noise | cache_site &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sitecache&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mdfilename&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>evict_cache_qmark&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>so that &amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">panwww &lt;span style="color:#e6db74">&amp;#34;https://www.recurse.com/&amp;#34;&lt;/span> | less &lt;span style="color:#75715e"># fetches site the first time&lt;/span>
panwww &lt;span style="color:#e6db74">&amp;#34;https://www.recurse.com/&amp;#34;&lt;/span> | less &lt;span style="color:#75715e"># looks up &amp;#34;cache&amp;#34;&lt;/span>
panwww &lt;span style="color:#e6db74">&amp;#34;https://www.recurse.com/&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;refetch&amp;#34;&lt;/span> | less
&lt;/code>&lt;/pre>&lt;/div></content></item></channel></rss>